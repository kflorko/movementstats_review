---
title: "Appendix 3"
author: "Katie Florko"
date: "30/11/2022"
output: html_document
theme: cosmo
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# Overview

This document contains the code from "*A comparison of statistical models used to characterize species-habitat associations with movement data*". This code includes the case study analysis on ringed seal movement in eastern Hudson Bay, Canada.

# Prepare
## Load packages

```{r, message = FALSE, warning = FALSE}
library(tidyverse)
library(ggplot2)
library(lubridate)
library(rnaturalearth)
library(rgdal)
library(terra)
library(amt)
library(momentuHMM)
library(viridis)
library(sf)
library(here)
```

## Fish data

Next we load in the fish data. This is a subset of the data from Florko et al. (2021).
```{r}

# load fish data
fish <- read.csv(here("data/preydiv.csv"))
head(fish)

```

Visualize the fish data.
```{r, message = FALSE}

#prepare world data
## List of azimuthal equal area - HudsonBay 
natearth <- ne_countries(scale = "medium",returnclass = "sp")
natearth <- natearth[which(natearth$continent!="Antarctica"),]
nat_trans <- spTransform(natearth,CRS("+proj=laea +lat_0=60 +lon_0=-85 +x_0=0 +y_0=0 +datum=WGS84 +units=m +no_defs +ellps=WGS84 +towgs84=0,0,0"))

# plot fish map
fishmap <- ggplot() + 
  geom_tile(data = fish, aes(x = lon,y = lat,fill = preydiv)) +
  scale_fill_viridis(option = "mako", limits = c(0.5, 0.75), name = "Prey\ndiversity") +
  geom_polygon(data = nat_trans, aes(x=long,y=lat,group=group), fill = "grey80", color = "white") +
  coord_cartesian(xlim = c(150000,550000), ylim = c(-500000,-50000), expand = F) 
fishmap
```


## Seal data

Next we load in the seal movement data. This is a subset of the data from Florko et al. (2023).
```{r, message = FALSE}

seal <- read.csv(here("data/seal_track_m.csv")) 
head(seal)

# ensure the data is in the correct format
seal <- seal %>%
  mutate(id = as.character(id),
         date = as.Date(date)) 
```

Visualize the seal data on top of the fish data.
```{r}

# plot
sealfishmap <- fishmap + 
  geom_point(data=seal, aes(x=lon, y=lat), alpha = 0.6, color = "#FCEEAE") + 
  geom_path(data=seal, aes(x=lon, y=lat), color = "#FCEEAE") 

sealfishmap

```

# Fit models
#1. RSF
Fit using amt (Signer et al. 2019)
```{r}
# generate availability sample
set.seed(2023)
data_rsf <- seal %>%
  make_track(lon, lat, date) %>%
  random_points() # default is ten times as many available points as observed points

# plot used vs available locations
sealfishmap +
  geom_point(data=data_rsf, aes(x=x_, y=y_, color = case_), alpha = 0.6) +
  scale_color_manual(values = c("black", "#FCEEAE"), 
                     label = c("Available", "Observed"), name = "Data type") 

# rasterize and extract prey diversity covariate
fish_raster <- terra::rast(fish, crs = CRS("+proj=longlat +ellps=WGS84 +datum=WGS84 +no_defs"))

data_rsf <- data_rsf %>%
  extract_covariates(fish_raster)

# fit rsf
rsf1 <- data_rsf %>%
  amt::fit_rsf(case_ ~ preydiv, model = TRUE)

# see parameter estimates
summary(rsf1)
```

#2. SSF
Fit using amt (Signer et al. 2019)
```{r, message = FALSE}

# generate availability sample
set.seed(2023)
data_ssf <- seal %>%
  make_track(lon, lat, date) %>%
  steps() %>%
  random_steps() %>% # default is ten times as many available points as observed points
  arrange(case_)

# plot used vs available locations
sealfishmap +
  geom_point(data=data_ssf, aes(x=x2_, y=y2_, color = case_), alpha = 0.6) +
  scale_color_manual(values = c("black", "#FCEEAE"), 
                     label = c("Available", "Observed"), name = "Data type") 

# extract prey diversity covariate
data_ssf <- data_ssf %>%
  extract_covariates(fish_raster, where = "end") #sample at end of step

# transform movement covariates
data_ssf <- data_ssf %>%
  mutate(cos_ta = cos(ta_),
         log_sl = log(sl_))

# fit ssfs
## ssf1: ssf without covariate affecting movement kernel
ssf1 <- data_ssf %>%
  fit_clogit(case_ ~ preydiv + log_sl + cos_ta + strata(step_id_), model = TRUE)

## ssf2: ssf with covariate affecting movement kernel
ssf2 <- data_ssf %>%
  fit_clogit(case_ ~ log_sl * preydiv + cos_ta * preydiv + strata(step_id_), model = TRUE)

# see parameter estimates
summary(ssf1)
summary(ssf2)
```


#3. HMM
Fit using momentuHMM (McClintock and Michelot, 2018)
```{r, message = FALSE}
# prepare dataset
data_hmm <- seal %>%
  make_track(lon, lat, date) %>%
  extract_covariates(fish_raster) %>%
  mutate(ID = 1,
         x = x_,
         y = y_,
         date = t_) %>%
  dplyr::select(ID, x, y, date, preydiv) %>%
  as.data.frame()

# convert into momentuHMM format
data_hmm <- momentuHMM::prepData(data_hmm, coordNames = c("x", "y"), 
                                 type = "UTM",
                                 covNames = c("preydiv"))

# define initial parameters
nbStates <- 3 # number of states
stepDist <- "gamma" # step distribution
angleDist <- "vm" # turning angle distribution

mu0 <- c(5000, 18000, 38000) # mean step length for each state
sigma0 <- c(5000,  10000, 10000) # sd step length for each state
stepPar0 <- c(mu0, sigma0) 
kappa0 <- c(0.35, 0.55, 0.5) # turning angle for each state

formula = ~ preydiv # identify covariates

# fit basic 3-state hmm
set.seed(2023)
hmm1 <- momentuHMM::fitHMM(data=data_hmm, nbStates=nbStates,
            dist=list(step=stepDist,angle=angleDist),
            Par0=list(step=stepPar0,angle=kappa0))

# retrieve parameters to refine model
Par0_hmm1 <- momentuHMM::getPar0(hmm1, formula=formula)

# fit a refined hmm with parameters from hhm1
set.seed(2023)
hmm2 <- momentuHMM::fitHMM(data=data_hmm, nbStates=3,
            dist=list(step=stepDist,angle=angleDist),
            Par0=Par0_hmm1$Par,
            delta0 = Par0_hmm1$delta, 
            beta0 = Par0_hmm1$beta,
            formula=formula)

# plot decoded states
data_hmm$state <- as.factor(momentuHMM::viterbi(hmm2))
hmmstate_plot <- ggplot() + 
  scale_fill_viridis(option = "mako", limits = c(0.5, 0.75), name = "Prey\ndiversity") +
  geom_path(data=data_hmm, aes(x=x, y=y, color = state, group =ID)) + 
  geom_point(data=data_hmm, aes(x=x, y=y, color = state, shape = state), size=2, alpha = 0.8) + 
  scale_color_manual(values = c("#99DDB6", "#539D9C", "#312C66"), 
                     labels = c("Localized\nsearch", "Area-restricted\nsearch", "Travelling"), 
                     name = "HMM state") +
  scale_shape_manual(values = c(15, 16, 17), 
                     labels=c("Localized\nsearch", "Area-restricted\nsearch", "Travelling"), 
                     name = "HMM state") +
  geom_polygon(data = nat_trans, aes(x=long,y=lat,group=group), fill = "grey80", color = "white") +
  coord_cartesian(xlim = c(150000,550000), ylim = c(-500000,-50000), expand = F)
hmmstate_plot


#---------------------PLOT HISTOGRAMS

## prep data in lat/lon and refit model (so step length is in kilometers)
data_hmm <- seal %>%
  make_track(lon, lat, date) %>%
  extract_covariates(fish_raster) %>%
    mutate(ID = 1,
         x = x_,
         y = y_,
         date = t_) %>%
  dplyr::select(ID, x, y, date, preydiv) %>%
  as.data.frame() %>%
  st_as_sf(coords = c("x", "y")) %>%
  st_set_crs("+proj=laea +lat_0=60 +lon_0=-85 +x_0=0 +y_0=0 +datum=WGS84 +units=m +no_defs +ellps=WGS84 +towgs84=0,0,0") %>%
  st_transform("+proj=longlat +datum=WGS84") %>%
  mutate(long = unlist(map(geometry,1)),
          lat = unlist(map(geometry,2))) %>%
  st_drop_geometry()

# do momentuhmm which calculates step length in KM
data_hmm <- momentuHMM::prepData(data_hmm, coordNames = c("long", "lat"), type = "LL", covNames = c("preydiv"))

hist(data_hmm$step)

# define parameters
nbStates <- 3
stepDist <- "gamma" # step distribution
angleDist <- "vm" # turning angle distribution

mu0 <- c(5, 12, 38)
sigma0 <- c(3, 5, 8)
stepPar0 <- c(mu0, sigma0)
kappa0 <- c(0.35, 0.55, 0.5)

set.seed(2023)
hmm1_km <- momentuHMM::fitHMM(data=data_hmm, nbStates=nbStates,
            dist=list(step=stepDist,angle=angleDist),
            Par0=list(step=stepPar0,angle=kappa0))

# get starting parameters 
Par0_hmm1_km <- momentuHMM::getPar0(hmm1_km, formula=formula)

# fit hmm with formula
set.seed(2023)
hmm2_km <- momentuHMM::fitHMM(data=data_hmm, nbStates=3,
            dist=list(step=stepDist,angle=angleDist),
            Par0=Par0_hmm1_km$Par,
            delta0 = Par0_hmm1_km$delta, 
            beta0 = Par0_hmm1_km$beta,
            formula=formula)

# add the state estimate from the HMM
data_hmm$state <- as.factor(momentuHMM::viterbi(hmm2_km))


##-----STEP DIST histogram

#calculate frequencies of states
v <- momentuHMM::viterbi(hmm2_km)
stateFreq <- table(v) / length(v)

#plot colours
colours.states <- c("#99DDB6", "#539D9C", "#312C66")

#generate sequence for x axis of density functions
x <- seq(0, 50, length=1000)

#get converged mean and sd for each state 
meanARS <- hmm2_km$mle$step[1,1]  
sdARS <- hmm2_km$mle$step[2,1]    

meanCR <- hmm2_km$mle$step[1,2]    
sdCR <- hmm2_km$mle$step[2,2]     

meanTR <- hmm2_km$mle$step[1,3]    
sdTR <- hmm2_km$mle$step[2,3]    

#calculate shape and scale of the gamma distributions from mean and sd
sh <- function(mean, sd) { return(mean^2 / sd^2)}
sc <- function(mean, sd) { return(sd^2 / mean)}

#get density functions of the distributions
y_ARS <- dgamma(x, shape=sh(meanARS,sdARS),  scale=sc(meanARS,sdARS)) * stateFreq[[1]]
y_CR <- dgamma(x, shape=sh(meanCR,sdCR),  scale=sc(meanCR,sdCR)) * stateFreq[[2]]
y_TR <- dgamma(x, shape=sh(meanTR,sdTR),  scale=sc(meanTR,sdTR)) * stateFreq[[3]]


#combine densities in a single dataframe for more convenient plotting
df.y_ARS <- data.frame(dens=y_ARS, State="Foraging", x=x)
df.y_CR <- data.frame(dens=y_CR,  State="ARS", x=x)
df.y_TR <- data.frame(dens=y_TR,  State="Travelling", x=x)
statedis <- rbind(df.y_ARS, df.y_CR, df.y_TR)

#plot distributions
hmmstepdist_plot <- ggplot() +
  geom_line(data=statedis,aes(x=x,y=dens,colour=State,linetype=State), size=1.2) +
  scale_colour_manual(values=c(colours.states,"#000000"), 
              breaks = c('Foraging', 'ARS', 'Travelling'), 
              labels=c("Localized\nsearch", "Area-restricted\nsearch", "Travelling")) +
  scale_linetype_manual(values=c("solid","solid", "solid"), 
              breaks = c('Foraging', 'ARS', 'Travelling'), 
              labels=c("Localized\nsearch", "Area-restricted\nsearch", "Travelling")) +
  ylab("Density") + 
  xlab("Step length (kms)") 
hmmstepdist_plot

##-----ANGLE DIST
# #generate sequence for x axis of density functions
x <- seq(-pi, pi,length=1000)

#get converged mean and concentration for each state 
meanARS <- hmm2_km$mle$angle[1,1]  
sdARS <- hmm2_km$mle$angle[2,1]    

meanCR <- hmm2_km$mle$angle[1,2]    
sdCR <- hmm2_km$mle$angle[2,2]  

meanTR <- hmm2_km$mle$angle[1,3]    
sdTR <- hmm2_km$mle$angle[2,3]  

#get density functions of the distributions
y_ARS <- CircStats::dvm(x, mu=meanARS,  kappa=sdARS) * stateFreq[[1]]
y_CR <- CircStats::dvm(x, mu=meanCR,  kappa=sdCR) * stateFreq[[2]]
y_TR <- CircStats::dvm(x, mu=meanTR,  kappa=sdTR) * stateFreq[[3]]


#combine densities in a single dataframe for more convenient plotting
df.y_ARS <- data.frame(dens=y_ARS, State="Foraging",x=x)
df.y_CR <- data.frame(dens=y_CR,  State="ARS",x=x)
df.y_TR <- data.frame(dens=y_TR,  State="Travelling",x=x)

cmb <- rbind(df.y_TR, df.y_CR, df.y_ARS)

#plot distributions
hmmangledist_plot <- ggplot() +
  geom_line(data=cmb,aes(x=x,y=dens,colour=State), size = 1.2) +
  scale_colour_manual(values=c(colours.states), breaks = c('Foraging', 'ARS', 'Travelling'), labels=c("Localized\nsearch", "Area-restricted\nsearch", "Travelling")) +
  scale_x_continuous(limits=c(-pi,pi))+
  ylab("Density") + 
  xlab("Turn angle (radians) ") 
hmmangledist_plot
```

# Plot prediction maps
```{r}
# prep the fish data
newfish <- fish_raster %>%
  rasterToPoints() %>%
  as.data.frame() %>%
  filter(x > 100000 & x < 600000 & y > -550000 & y < 0)

# range function
range01 <- function(x){(x-min(x))/(max(x)-min(x))}
```


#1. RSF
```{r}

modcoef <- summary(rsf1)$coef
x <- exp(modcoef[1] + (modcoef[2] * newfish$preydiv))
x <- x / (1 + x)
newfish$rsf_prediction <-range01(x)

# plot
map_RSF <- ggplot() + 
  geom_tile(data = newfish, aes(x = x,y = y, fill = rsf_prediction)) +
  scale_fill_viridis(option = "mako", name = "RSF prediction", limits = c(0, 0.3)) +
  geom_polygon(data = nat_trans, aes(x=long,y=lat,group=group), fill = "grey80", color = "white") +
  coord_cartesian(xlim = c(150000,550000), ylim = c(-500000,-50000), expand = F) 
map_RSF

```

#2. SSF

```{r}

#------- my turn
class(fish_raster) #good

# generate availability sample
set.seed(2023)
data_ssf <- seal %>%
  mutate(date = as.POSIXct(date)) %>%
  make_track(lon, lat, date) %>%
  steps() %>%
  random_steps() %>% 
  arrange(case_) %>%
  extract_covariates(fish_raster, where = "both") %>%
  na.omit()

class(data_ssf)
head(data_ssf) # should have burst_
summary(data_ssf)

# fit model
m1 <- data_ssf |> 
  fit_clogit(case_ ~ preydiv_end +  preydiv_start:cos(ta_) + 
               preydiv_start:sl_ + strata(step_id_))
summary(m1)


# Start with simulations
# First generate a redistribution kernel
start <- make_start((seal %>%
                       mutate(date = as.POSIXct(date)) %>%
                       make_track(lon, lat, date))[1, ]) # This is the starting location (we could sample it randomly from within the area we want to )
k1 <- redistribution_kernel(m1, map = fish_raster, start = start)

# Now simulate a path of length 30 for 50 times. This will lead a transient UD. For a steady state UD, either increase `n` or choose many more random starting points. 
n <- 50
p1 <- replicate(n, simulate_path(x = k1, n = 10, start = start, verbose = TRUE), simplify = FALSE) # Takes about 2 min

uds <- lapply(c(5, 5), function(i) {
  tibble(
    rep = 1:n, 
    path = map(p1, ~ dplyr::slice(.x, i))
  ) |> unnest(cols = path) |> filter(!is.na(x_)) |> 
    make_track(x_, y_) |> hr_kde(trast = fish_raster, which_min = "global")
})

#saveRDS(uds, file="uds.RData") 

terra::plot(hr_ud(uds[[1]]))
terra::plot(hr_ud(uds[[2]]))












data_ssf_noNA <- data_ssf[complete.cases(data_ssf),]

ssf1 <- data_ssf_noNA %>%
  fit_issf(case_ ~ preydiv + strata(step_id_), model = TRUE)


# 1. make_start()
ms <- make_start(
  x = c(pull(data_ssf_noNA[1, "x1_"]), pull(data_ssf_noNA[1, "y1_"])),
  cos_ta = 0,
  log_sl = 10,
  time = pull(data_ssf_noNA[1, "t1_"]),
  dt = days(1),
  crs = crs(fish_raster))

# 2. get_max_dis()
gmd <- get_max_dist(ssf1, p = 0.99)


# 3. redistribution_kernel()
rd_k <- redistribution_kernel(
  x = ssf1,
  start = ms,
  map = terra::rast(fish_raster),
  fun = function(xy, map) {
  extract_covariates(xy, raster::stack(map), where = "both")  # make terra object into rasterStack
},
  covars = NULL,
  max.dist = gmd,
  n.control = 1e+06,
  n.sample = 10,
  stochastic = TRUE,
  compensate.movement = FALSE,
  normalize = TRUE,
  interpolate = FALSE,
  as.rast = FALSE,
  tolerance.outside = 5)

rd_k


fish_raster <- rasterFromXYZ(fish, crs = CRS("+proj=longlat +ellps=WGS84 +datum=WGS84 +no_defs"))
redistribution_kernel(ssf1,
map = rast(raster::stack(fish_raster)),
start = ms,
stochastic = TRUE, tolerance.outside = 0.2,
n.control = 1e5, n.sample = 1000)








#######----------DEPRECATED WAY
##---- ssf1: ssf without covariate affecting movement kernel

# define habitat kernel
hk <- habitat_kernel(
  coef = coef(ssf1)["preydiv"], 
  resources = fish_raster$preydiv)

# simulate utlization distribution
ssud_day <- simulate_ud(movement_kernel = hk,
                        habitat_kernel = hk,
                        start = as.numeric(data_ssf[1, c("x1_", "y1_")]),
                        n = 1e7)

# convert to dataframe
ssud_day <- as.data.frame(ssud_day, xy=TRUE)

# plot
map_SSF_withoutmvmt <- ggplot() + 
  geom_tile(data = ssud_day, aes(x = x,y = y,fill = layer)) +
  scale_fill_viridis(option = "mako", name = "SSF Probability\n(without movement*prey)\n", limits = c(0,0.03)) +
  geom_polygon(data = nat_trans, aes(x=long,y=lat,group=group), fill = "grey80", color = "white") +
  coord_cartesian(xlim = c(150000,550000), ylim = c(-500000,-50000), expand = F)
map_SSF_withoutmvmt


##---- ssf2: ssf with covariate affecting movement kernel

# grab step data
sl_char <- amt::sl_distr(filter(data_ssf, case_ == "TRUE"))

# define movement kernel
mk <- movement_kernel(
  shape = sl_char$params$shape, 
  scale = sl_char$params$scale, 
  template = fish_raster$preydiv)

# define habitat kernel
hk <- habitat_kernel(
  coef = coef(ssf2)["preydiv"], 
  resources = fish_raster$preydiv)

# simulate utlization distribution
ssud_day <- simulate_ud(movement_kernel = mk,
                        habitat_kernel = hk,
                        start = as.numeric(data_ssf[1, c("x1_", "y1_")]),
                        n = 1e7)

# convert to dataframe
ssud_day <- as.data.frame(ssud_day, xy=TRUE)

# plot
map_SSF_withmvmt <- ggplot() + 
  geom_tile(data = ssud_day, aes(x = x,y = y,fill = layer)) +
  scale_fill_viridis(option = "mako", name = "SSF Probability\n(with movement*prey)\n", limits = c(0,0.08)) +
  geom_polygon(data = nat_trans, aes(x=long,y=lat,group=group), fill = "grey80", color = "white") +
  coord_cartesian(xlim = c(150000,550000), ylim = c(-500000,-50000), expand = F)
map_SSF_withmvmt


```

#3. HMM
```{r}
x <- as.data.frame(momentuHMM::stationary(hmm2, data.frame(preydiv = newfish$preydiv)))
newfish$hmm_state1 <- x$state.1
newfish$hmm_state2 <- x$state.2
newfish$hmm_state3 <- x$state.3 

newfish_long <- newfish %>%
  pivot_longer(cols = hmm_state1:hmm_state3, 
               names_to = "model", values_to = "prediction") %>%
  mutate(across(model, factor, levels=c("hmm_state1", "hmm_state2", "hmm_state3")))

map_HMM <- ggplot() + 
  geom_tile(data = newfish_long, aes(x = x, y = y, fill = prediction)) +
  scale_fill_viridis(option = "mako", limits = c(0,1)) +
  labs(fill = 'HMM predicted\nprobability') +
  geom_polygon(data = nat_trans, aes(x=long,y=lat,group=group), colour = "white", fill = "grey90", size = 0.3) +
  coord_cartesian(xlim = c(150000,550000), ylim = c(-500000,-50000), expand = F) +
  facet_wrap(~model, labeller = as_labeller(c('hmm_state1' = "Localized search",
                                              'hmm_state2' = "Area-restricted search",
                                              'hmm_state3' = "Travel")))
map_HMM
```


# Plot prey div vs probability of selection
#1. RSF
```{r}
pred <- data.frame(preydiv = ps$preydiv$'state 1'$cov)

rsf2 <- glm(relevel(as.factor(case_), ref = "FALSE") ~ 
            preydiv,
            family = "binomial",
            data = data_rsf)

preds <- predict(rsf2, 
                 newdata = pred, 
                 type = "response", 
                 se.fit = TRUE)

# calculate se
critval <- 1.96 ## approx 95% CI 
preds$upr <- preds$fit + (critval * preds$se.fit)
preds$lwr <- preds$fit - (critval * preds$se.fit)

# combine data frame
preds2 <- data.frame(preydiv = pred$preydiv,
                     model = "rsf",
                     fit = preds$fit, 
                     se = preds$fit - preds$upr)

# plot to make sure it looks right
ggplot(data=preds2, mapping=aes(x=preydiv,y=fit)) + geom_line() +  
  geom_ribbon(aes(ymin=fit-se, ymax=fit+se, x=preydiv), alpha = 0.3) +
  ylab("RSF prediction") +
  xlab("Prey diversity")

```



#2. SSF
```{r}
# prep the fish data
newfish <- fish_raster %>%
  terra::as.data.frame(xy = TRUE) %>%
  filter(x > 100000 & x < 600000 & y > -550000 & y < 0)

# Make a base data.frame to create x1 and x2 from:
# Start with all the combinations of arccod, capelin, and nsandlance
base <- newfish %>% 
  #  (note, it doesn't matter what values you pick for sl_ and ta_)
  mutate(log_sl = log(45),
         cos_ta = cos(1))

# Now we can create x1 and x2, with the only difference being map = 1 in x1
# and map = 0 in x2.
x1 <- base 
#x11 <- x1
x1$log_sl <- 40

x2 <- base  %>% 
  mutate(preydiv = mean(base$preydiv))

# So how do we iterate this? We could use a for loop, we could use lapply, etc.
# I will use lapply here, with a custom function inside.

log_rss_list <- lapply(1:nrow(x1), function(i) {
  # Report status
  cat(i, "of", nrow(x1), "\n")
  # Calculate log-RSS for that row
  xx <- log_rss(ssf2, x1[i,], x2[i,], ci = "se")
  # Return the element $df
  return(xx$df)
})

# We now have a list with an element for each row. We can combine those rows
# into a single data.frame with 'dplyr::bind_rows()'
res <- dplyr::bind_rows(log_rss_list)

# This object is ready for plotting. For example:
ggplot(res, aes(x = preydiv_x1, y = (log_rss))) +
  geom_line(size = 1) +
  geom_ribbon(aes(ymin=lwr, ymax=upr, x=preydiv_x1), alpha = 0.3) +
  xlab("Prey diversity") +
  ylab("log-RSS vs Mean Prey Diversity") 
  








## LOOP ATTEMPT - THIS IS THE ONE
seal %>%
  make_track(lon, lat, date) %>%
  steps %>%
  summarize(quants = quantile(sl_, c(0.25, 0.5, 0.75))) %>%
  pull()

nums = c(1,2,10)

results <- lapply(nums, function(i) {
  x1 <- base 
#x11 <- x1
x1$log_sl <- i

x2 <- base  %>% 
  mutate(preydiv = mean(base$preydiv))

# So how do we iterate this? We could use a for loop, we could use lapply, etc.
# I will use lapply here, with a custom function inside.

log_rss_list <- lapply(1:nrow(x1), function(i) {
  # Report status
  cat(i, "of", nrow(x1), "\n")
  # Calculate log-RSS for that row
  xx <- log_rss(ssf2, x1[i,], x2[i,], ci = "se")
  # Return the element $df
  return(xx$df)
})

# We now have a list with an element for each row. We can combine those rows
# into a single data.frame with 'dplyr::bind_rows()'
res <- dplyr::bind_rows(log_rss_list)

} )
results <- dplyr::bind_rows(results) %>%
  mutate(log_sl_x1 = as.factor(log_sl_x1))

# PLOT
ggplot(results, aes(x = preydiv_x1, y = (log_rss))) +
  geom_line(size = 1, aes(color = log_sl_x1, group = log_sl_x1)) +
  geom_ribbon(aes(ymin=lwr, ymax=upr, x=preydiv_x1, fill = log_sl_x1, group = log_sl_x1), alpha = 0.3) +
  xlab("Prey diversity") +
  ylab("log-RSS vs Mean Prey Diversity") 
  








### ATTEMPT JUNE 26 2023

###----- SSF without prey diversity affecting movement

# refit in survival
ssf1_m <- survival::clogit(case_ ~ 
             preydiv + log_sl + cos_ta + strata(step_id_), 
             data = data_ssf)

predsk <- predict(ssf1_m, 
          newdata = data.frame(
            preydiv = pred$preydiv,
            log_sl = log(mean(na.omit(data_hmm$step))), # mean SL
            cos_ta = cos(mean(na.omit(data_hmm$angle))), # mean TA
            step_id_ = 1), 
          se.fit = TRUE)

# calculate se
critval <- 1.96 ## approx 95% CI 
predsk$upr <- predsk$fit + (critval * predsk$se.fit)
predsk$lwr <- predsk$fit - (critval * predsk$se.fit)

# combine data frame
preds2kssf <- data.frame(preydiv = pred$preydiv,
                     model = "ssf",
                     fit = predsk$fit, 
                     se = predsk$fit - predsk$upr)

# plot 
ggplot(data=preds2kssf, mapping=aes(x=preydiv,y=fit)) + geom_line() +  
  geom_ribbon(aes(ymin=fit-se, ymax=fit+se, x=preydiv), alpha = 0.3) +
  ylab("SSF Prediction") + xlab("Prey diversity")


# combine with RSF plot
rbind(preds2kssf, preds2) %>%
  ggplot() + geom_line(aes(x=preydiv, y=fit, color = model)) +
  geom_ribbon(aes(ymin=fit-se, ymax=fit+se, x=preydiv, fill = model), 
              alpha = 0.3) +
  ylab("Prediction") + xlab("Prey diversity") 


###----- SSF with prey diversity affecting movement

# refit in survival
ssf2_m <- survival::clogit(case_ ~ 
             preydiv*log_sl + preydiv*cos_ta + strata(step_id_), 
             data = data_ssf)


# define number of availability points per one used point
speeds <- c(1, 2, 3)
speed.i = 1

# create empty list
grab = list()
for(speed.i in unique(speeds)){
  
 # predict new data
  preds <- predict(ssf2_m, 
          newdata = data.frame(
            preydiv = pred$preydiv,
            log_sl = log(Par0_hmm1$Par$step[speed.i]), # set speed
            cos_ta = cos(mean(na.omit(data_hmm$angle))), # mean turning angle 
            #step_id_ = unique(data_ssf$step_id_)[1:101],
            step_id_ = unique(data_ssf$step_id_)[10]), 
          se.fit = TRUE)
  
 # calculate se
  critval <- 1.96 ## approx 95% CI 
  preds$upr <- preds$fit + (critval * preds$se.fit)
  preds$lwr <- preds$fit - (critval * preds$se.fit)
  
  # combine data frame
  preds_speed <- data.frame(preydiv = pred$preydiv,
                     rsf_speed = speed.i,
                     fit = preds$fit, 
                     se = preds$fit - preds$upr)

 # output
  grab[[speed.i]] <- preds_speed
}

resultdf <- bind_rows(grab) %>%
  as_tibble() %>%
  mutate(rsf_speed = as.factor(rsf_speed))

ggplot() +
  geom_line(data=resultdf, aes(x=preydiv,y=fit, color = rsf_speed)) +  
  geom_ribbon(data=resultdf, aes(ymin=fit-se, ymax=fit+se, x=preydiv, fill= rsf_speed), alpha = 0.3) +
  ylab("SSF Prediction") + xlab("Prey diversity")



### ATTEMPT JUNE 27 afternoon
# Grab the coefficients (b for beta)
b <- coef(ssf2)


# coef for preydiv as a function of log_sl
coef_log_sl_ <- function(b, log_sl) {
  
  res <- b[["log_sl"]] +
    b[["preydiv"]] +
    b[["cos_ta"]] +
    b[["log_sl:preydiv"]] * log_sl +
    b[["preydiv:cos_ta"]]
  return(res)
}

# E.g.,
coef_log_sl_(b, log_sl = 5)


# Start with the combinations of step lengths
sl_fig <- expand.grid(log_sl = c(5, 7, 9)) %>% 
  # Calculate the betas for each
  mutate(beta_log_sl = coef_log_sl_(b, log_sl = log_sl))


# For each row, get the updated shape and scale for the selection-free step-length
# distribution (this function is vectorized)
sf_dist <- update_gamma(sl_distr(ssf2),
             beta_sl = sl_fig$beta_sl,
             beta_log_sl = sl_fig$beta_log_sl)

sl_fig$shape <- sf_dist$params$shape
sl_fig$scale <-1

# Now get likelihood from gamma distribution for a bunch of possible steps
preydiv <- seq(0.5, 0.7, length.out = 100)
sl_fig <- merge(sl_fig, y = data.frame(preydiv = preydiv)) %>% 
  mutate(like = dgamma(preydiv, shape = shape, scale = scale))


# Plot
ggplot(sl_fig, aes(x = preydiv, y = like, color = factor(log_sl))) +
  geom_line(size = 0.9) +
  xlab("Prey Diversity") +
  ylab("Likelihood") 
```


#3. HMM
```{r}
# grab stationary probabilities
ps <- momentuHMM::plotStationary(hmm2, plotCI= TRUE, return = TRUE)
state1 <- ps$preydiv$'state 1' %>% mutate(state = 1)
state2 <- ps$preydiv$'state 2' %>% mutate(state = 2)
state3 <- ps$preydiv$'state 3' %>% mutate(state = 3)

# bind to one data frame
pdat <- rbind(state1, state2, state3) %>%
  mutate(state = as.character(state)) 

# plot
hmmprobs_plot <- ggplot() + 
  geom_line(data = pdat, aes(x = cov, y = est, color = state)) +
  geom_ribbon(data = pdat, aes(x=cov, y=est, ymax=est+se, ymin=est-se, fill = state), 
              alpha = 0.4, show.legend = TRUE) +
  ylab("Stationary state probabilties") +
  xlab("Prey diversity") +
  scale_color_manual(values = c("#99DDB6", "#539D9C", "#312C66"), name = "HMM state",
                     labels=c("Localized\nsearch", "Area-restricted\nsearch", "Travel")) +
    scale_fill_manual(values = c("#99DDB6", "#539D9C", "#312C66"), name = "HMM state",
                     labels=c("Localized\nsearch", "Area-restricted\nsearch", "Travel")) 

hmmprobs_plot

```



# References 
Florko, K.R.N., Tai, T.C., Cheung, W.W.L., Sumaila, U.R., Ferguson, S.H., Yurkowski, D.J., Auger-Méthé, M. 2021. Predicting how climate change threatens the prey base of Arctic marine predators. Ecology Letters, 24: 2563-2575.

Florko, K.R.N., Shuert, C.R., Cheung, W.W.L., Ferguson, S.H., Jonsen, I.D., Rosen, D.A.S., Sumaila, U.R., Tai, T.C., Yurkowski, D.J., Auger-Méthé, M. 2023. Linking movement and dive data to prey distribution models: new insights in foraging behavior and potential pitfalls of movement analyses. Movement Ecology, 11:17 https://doi.org/10.1186/s40462-023-00377-2

McClintock, B.T., Michelot, T. 2018. momentuHMM: R package for generalized hidden markov models of animal movement. Methods Ecol. Evolut. 9, 1518-1530.

Signer, J., Fieberg, J., & Avgar, T. (2017). Estimating utilization distributions from fitted step‐selection functions. Ecosphere, 8(4), e01771.

Signer, J., J. Fieberg, and T. Avgar. 2019. Animal movement tools (amt): R package for managing tracking data and conducting habitat selection analyses. Ecology and Evolution 9:880–890.
