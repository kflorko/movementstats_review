---
title: "A comparison of statistical models used to characterize species-habitat associations with movement data: Appendix 3"
author: "Katie Florko, Ron Togunov, Marie Auger-Méthé"
date: "22/09/2023"
output:
  html_document:
    toc: yes
    toc_float: yes
    toc_depth: 3
    number_sections: yes
    theme: united
    highlight: tango
  word_document:
    toc: yes
    toc_depth: '3'
  pdf_document:
    toc: yes
    toc_depth: '3'
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# Overview

This document contains a coding tutorial that demonstrates how to perform the analyses associated with the case study in "*A review of statistical models used to characterize species-habitat associations with animal movement data*". All analyses link the movement data of a ringed seal in eastern Hudson Bay, Canada, to modeled prey diversity.

# Set-up  
## Load packages

```{r libraries, message = FALSE, warning = FALSE}
# data wrangling
library(here)
library(tidyverse)
library(lubridate)

# mapping
library(rnaturalearth)
library(rnaturalearthdata)
library(rgdal) 
#if you need to install, install from archive:
#devtools::install_version('rgdal', version = '1.6-7') )
library(terra)
library(tidyterra)
library(sf)
library(viridis)

# fitting models
library(amt) # for selection functions
library(momentuHMM) # for hidden Markov model
library(geosphere)

# plotting
library(ggplot2)
```

## Prey diversity data

Next we load in the fish data, which contains the spatial distribution of prey diversity in 2012. The data is in a .csv, and we will rasterize this using it's specific coordinate reference system. This is a subset of the data from Florko et al. (2021a, 2021b).

```{r load fish}
# load prey diversity data
fish <- read.csv(here("data/fish.csv"))

# rasterize prey diversity data
fish_raster <- terra::rast(fish, crs = "+proj=laea +lat_0=60 +lon_0=-85 +x_0=0 +y_0=0 +datum=WGS84 +units=m +no_defs +ellps=WGS84 +towgs84=0,0,0")

```

Visualize the fish data. 

```{r plot fish, message = FALSE}

# prepare land data for mapping
natearth <- ne_countries(scale = "medium",returnclass = "sf")
natearth <- natearth[which(natearth$continent!="Antarctica"),]

# projection: project land to match fish raster 
nat_trans <- st_transform(natearth, crs(fish_raster))

# plot fish map
fishmap <- ggplot() + 
  tidyterra::geom_spatraster(data = fish_raster) +
  scale_fill_viridis(option = "mako", limits = c(0.5, 0.75), name = "Prey\ndiversity") +
   geom_sf(data = nat_trans, fill = "grey80", color = "white") + 
   coord_sf(xlim = ext(fish_raster)[1:2], ylim = ext(fish_raster)[3:4], expand = F)
fishmap
```


## Seal data

Next we load in one movement track from a ringed seal equipped with an ARGOS satellite telemetry transmitter over the course of over four months in the winter of 2012-2013. This is a subset of the data from Florko et al. (2023a).

```{r seal data, message = FALSE}
# load seal data
seal <- read.csv(here("data/seal_track_m.csv")) 
head(seal)

# ensure the data is in the correct format
seal <- seal %>%
  mutate(id = as.character(id),
         date = as.Date(date)) 
```

Visualize the seal data on top of the fish data.
```{r plot seals}
# plot seal and fish data together
sealfishmap <- fishmap + 
  geom_point(data=seal, aes(x=lon, y=lat), alpha = 0.6, color = "#FCEEAE") + 
  geom_path(data=seal, aes(x=lon, y=lat), color = "#FCEEAE") 

sealfishmap
```

# Fit models

We will fit four main models: 1) a resource selection function (RSF), 2) a step selection function (SSF) without habitat covariates in the movement kernel, 3) a SSF with a habitat covariate modifying the movement kernel, and 4) a hidden Markov model (HMM). All four of these main models will include prey diversity as a covariate. Note that we also fit additional HMMs to demonstrate their flexibility.


All of the step selection functions (both the RSF and two SSFs) will be fit using the `amt` package (Signer et al. 2019), while the HMMs will use the functions from the `momentuHMM` package (McClintok and Michelot 2018). 


## RSF

The RSF is the simplest of the four models. Fitting an RSF to movement data first requires us to generate a sample of availability points and extract covariates for the used and available locations. 

```{r rsf data}
# prep data and generate availability sample
set.seed(2023)
data_rsf <- seal %>%
  make_track(lon, lat, date) %>% # convert data to track format
  random_points() # generate availability sample; default is ten times as many available points as observed points

# plot used vs available locations on-top of prey diversity
data_rsf_map <- sealfishmap +
  geom_point(data=data_rsf, aes(x=x_, y=y_, color = case_), alpha = 0.6) +
  scale_color_manual(values = c("black", "#FCEEAE"), 
                     label = c("Available", "Observed"), name = "Data type") 
data_rsf_map
```

We can see that the availability sample is generated within the minimum convex polygon of the used samples. 

We now extract covariate (prey diversity) values for the used and available locations.

```{r rsf extract}

data_rsf <- data_rsf %>%
  extract_covariates(fish_raster)

```

Next, we will fit the model. The response, `case_`, is the column in `data_rsf` that identifies whether the location is a used (`TRUE`) or available (`FALSE`) location, and `preydiv` is the covariate for prey diversity.

```{r rsf fit}

# fit rsf (a binomial logistic regression)
rsf1 <- data_rsf %>%
  amt::fit_rsf(case_ ~ preydiv, model = TRUE)

```

View the summary.
```{r rsf summary}
# see model summary
summary(rsf1)
```

We see that prey diversity is a significant positive covariate. We do not interpret the intercept, since it is not ecologically meaningful in a RSF. See Fieberg et al. (2021) for a detailed discussion on how to interpret parameters. 
 
## SSF

Next we will fit our two SSFs. The workflow is similar to that of the RSF, however, the availability sample is generated differently. We transform the seal locations into a track format, then convert the track data into step format (i.e., with a start and an end), and then generate the availability sample.

```{r ssf data}
# prep data and generate availability sample
data_obs_steps <- seal %>%
  make_track(lon, lat, date) %>% #  convert data to track format
  steps()

set.seed(2023)
data_ssf <- data_obs_steps %>% # convert track data to step format (i.e., with a start and an end)
  random_steps()  # generate availability sample 
```


By default, when applied to objects of class `step_xy`, the function `random_steps()` samples the step lengths from a gamma distribution with parameters estimated from the observed step lengths and turning angles from a von Mises distribution with parameters estimated from the observed turning angles.

Visualize the sample created.
```{r ssf plot}
# plot used vs available locations on-top of prey diversity
data_ssf_map <- sealfishmap +
  geom_point(data=data_ssf, aes(x=x2_, y=y2_, color = case_), alpha = 0.6) +
  scale_color_manual(values = c("black", "#FCEEAE"), 
                     label = c("Available", "Observed"), name = "Data type") 
data_ssf_map
```

We can see that the availability sample is generated at each step and is not restricted to the minimum convex polygon.

We now extract prey diversity values for the used and available locations.

```{r ssf extract, message = FALSE}

# extract prey diversity covariate
data_ssf <- data_ssf %>%
  extract_covariates(fish_raster, where = "end") #sample at end of step

```

We will transform both the step length and turning angle using log and cosine transformations, respectively.
```{r ssf dataprep}
# transform movement covariates
data_ssf <- data_ssf %>%
  mutate(cos_ta = cos(ta_),
         log_sl = log(sl_))
```

Next, we will fit the models. The response, `case_`, is the column of `data_ssf` that identifies whether the location is a used (`TRUE`) or available (`FALSE`) location, and `preydiv` is the covariate for prey diversity at that location. `log_sl` is the log transformation of step length, and `cos_ta` is the cosine transformation of turning angle. `strata(step_id_)` specifies that the this is a *conditional* logistic regression that groups data by step identification number.

We are fitting two SSFs: one without a movement-related covariate (called ssf1), and one with a movement-related covariate (called ssf2). 

```{r ssf fit}
# fit ssfs
## ssf1: ssf without covariate affecting movement kernel
ssf1 <- data_ssf %>%
  fit_clogit(case_ ~ preydiv + log_sl + cos_ta + strata(step_id_), model = TRUE)
#MAM: just checking the gamma thing discussed in the comments of the appendix
ssf1_b <- data_ssf %>%
  fit_clogit(case_ ~ preydiv + sl_ + log_sl + cos_ta + strata(step_id_), model = TRUE)


## ssf2: ssf with covariate affecting movement kernel
ssf2 <- data_ssf %>%
  fit_clogit(case_ ~ preydiv*log_sl + cos_ta + strata(step_id_), model = TRUE)

#MAM: just checking the gamma thing discussed in the comments of the appendix - 
ssf2_b <- data_ssf %>%
  fit_clogit(case_ ~ sl_ + preydiv*log_sl + cos_ta + strata(step_id_), model = TRUE)
```

First we will interpret ssf1. 
```{r ssf1 summary}
# see model summary
summary(ssf1)

#MAM: checking if it works with sl
summary(ssf1_b)
```


This model estimates the coefficients (coef) as well as the exponent of the coefficient (exp(coef)). The coefficients are as in our regular logistic regression (the RSF), and the exp(coef) quantifies the relative intensity of use of two locations that differ by 1 unit of prey diversity but are otherwise the same. The model suggests our seal would be 2.6 times more likely to choose a location with 1 unit higher prey diversity (see Fieberg et al. 2021). However, this is not significant (p = 0.888), and we see that the scale of prey diversity is much smaller (range = 0.5-0.75), and thus an increase in of 2.6 times per 1 unit prey diversity is not a meaningful increase.

#MAM: I don't think this statement is completely true. See other comment below. My understanding is that if no other process is affecting the movement, than we would expect the betas associated with sl and log_sl to be close to 0 (I'm not entirely sure for the von Mises, since they don't expend as much is Avgar et al) because we are using a conditional logistic regression and we have thus already estimated the based values when creating the available steps (thus it can be put in likelihood, they refer to Forester). However, I think that, if say the preydiversity is affecting selection, then you'd have potentially betas that are far from 0. I don't have a good sense of the magnitude at which they should be, but it does make sense that they are not really big and non-significant as it appears that the prey diversity selection is not changing things much. 
We don't interpret the values of log_sl or cos_ta, since we don't expect those to affect occurrence since the availability sample is generated using the step length and turning angle from the observed track.

#MAM: related to my comments in appendix, it might help to re-read Avgar et al 2015 in detail (main paper and appendix, note that there is a corrigedum that corrects a lot of equations/parameters) and state that they link to the parameters of the gamma and von Mises distribution (and thus are very similar to the HMMs you are fitting). I feel explaining a bit how they are link to the gamma and von Mises parameters would be good. With regards to the gamma, it may help to just read the wikipedia page on the topic (especially the table on the right). The main complication in Avgar (and I think Forester) is the fact that the conditionality of available steps that are sampled using estimated gamma and von Mises parameters make things a less straightforward. But this sentence from the main text is particularly helpful: "Once maximum-likelihood estimates are obtained, the shape and scale parameters of the basal step-length distribution can be calculated (Appendix S3), where the shape is given by: [(b1 + b7) + b8.Dt], and the scale is given by: [1/(b2^-1 – b6)]." b1 and b2 are the parameters from gamma distribution estimated from the steps (b1 is shape and b2 is scale). By default random_steps() use fit_distr(x$sl_, "gamma"), see help file. Note that the model we have here is slightly different, since there are no interactions with movement so it would be shape is given by: [(b1 + b7)] and scale: [1/(b2^-1 – b6)]. I think, please double check and/or ask Evan/Ron to double check with you.

```{r ssf1 parameter}
#MAM: Mainly to explain to you the parameters. But could be used to explain.
obs_sl_par <- fit_distr(data_obs_steps$sl_, "gamma")
b1 <- obs_sl_par$params$shape
b2 <- obs_sl_par$params$scale
# So final shape, after predy diversity selection is included would be
ssf1_gamma_shape <- b1 + summary(ssf1_b)$coef["log_sl",1]
b1
ssf1_gamma_shape # A bit different
# Final scale:
ssf1_gamma_scale <- 1/(1/b2 - summary(ssf1_b)$coef["sl_",1])
b2
ssf1_gamma_scale
# Mean difference between observed and modified by prey diversity selection
# Mean step length from gamma parametric with observed step length
b1*b2
# Mean step length from gamma modified by prey diversity.
# Note that by definition, the mean of the gamma is shape*scale
ssf1_gamma_shape*ssf1_gamma_scale

```

We also see that we get a warning "2 observations deleted due to missingness", due to two of our available locations being found on land, where we do not have fish values. This could be mitigated by generating more than 10 (i.e., 15) available locations per used location, omitting the samples without prey diversity values, and then randomly selecting 10 available locations per used location of those that have values for prey diversity.


Next we will interpret ssf2. 

```{r ssf2 summary}
# see model summary
summary(ssf2)

#MAM: checking if it works with sl
summary(ssf2_b) # In essence they are the same. My understanding (see above) is that you get zero for sl, probably because the prey diversity is not changing the movement and the samples steps were sample using the estimated gamma parameters from the observed steps
```

Similar to ssf1, we don't see any significant relationships. Note that we also included a term for preydiv*log_sl. Since we have this interaction, preydiv and log_sl cannot be interpreted independently, thus we interpret the interaction. The interaction is not significant, so this model does not suggest that prey diversity affects the movement speed of our ringed seal.

#MAM: I'm not sure the above is completely true, or at least it makes it feel like there is not much one can take out of this, when some insight can be gained. From Avgar et al. it appears that you can interpret negative preydiv:log_sl beta as meaning that long step length are less likely in higher prey diversity area (though not significant). While not significant, I think that matches the HMMs results, no? See my detailed info above, here the scale parameter is like above, but the shape is modified by prey diversity, which means that we have (b1 + b7) + b8* preydiv], where b1 is again the b1 from the observed data, b7 is the coef associated with log_sl, and b8 is the coef value associated with preydiv:log_sl, and it means that if negative than the shape decreases with increasing preydiv, which mean that the mean step length decreases with increasing predy diversity. One important note, is I think the results from the ssf makes sense they are just not significant.

#MAM: Main note, I would change everything to include the sl and ln(sl), so using model ssf1_b and ssf2_b (and make the change in the main text and appendix). That makes the relationship with gamma straightforward. If you prefer sticking with the original, than explain why (maybe somewhere they say that the scale is rarely affacted in iSSA, please cite if that's the case).

## HMM

### 2-state HMMs

Finally, we will fit the HMM using `momentuHMM` (McClintock and Michelot, 2018). In preparation, we define initial parameters, and then update the parameters using our fit model, to ultimately fit a more refined model. We will first fit a two-state model.

#MAM: same as above. I think in the end you have multiple 3-states HMMs. So worth clarifying up-front to be consistant.

This HMM example is parameterized to allow the covariate, prey diversity, influence the state transition probability. We can also allow covariates to influence the observation probabilities. These covariates are typically abiotic, but we show a brief example of how one would fit such a model below our main HMM.


```{r prep hmm data , message = FALSE}

## prepare the data
data_hmm <- seal %>%
  make_track(lon, lat, date) %>%
  extract_covariates(fish_raster) %>%
    mutate(ID = 1,
         x = x_,
         y = y_,
         date = t_) %>%
  dplyr::select(ID, x, y, date, preydiv) %>%
  as.data.frame() %>%
  st_as_sf(coords = c("x", "y")) %>%
  st_set_crs("+proj=laea +lat_0=60 +lon_0=-85 +x_0=0 +y_0=0 +datum=WGS84 +units=m +no_defs +ellps=WGS84 +towgs84=0,0,0") %>%
  st_transform("+proj=longlat +datum=WGS84") %>%
  mutate(long = unlist(map(geometry,1)),
         lat = unlist(map(geometry,2))) %>%
  st_drop_geometry()

# calculate step length
data_hmm <- momentuHMM::prepData(data_hmm, coordNames = c("long", "lat"), type = "LL", covNames = c("preydiv"))

```

#### Basic 2-state HMM

Define the starting parameters.

```{r define starting parameters hmm1, message = FALSE}

# define parameters
nbStates <- 2 # number of states
stepDist <- "gamma" # step distribution
angleDist <- "vm" # turning angle distribution
dist <- list(step=stepDist,angle=angleDist)

mu0 <- c(8, 38) # mean step length for each state
sigma0 <- c(8, 8) # sd step length for each state
stepPar0 <- c(mu0, sigma0)
kappa0 <- c(0.35, 0.35)  # turning angle for each state
```

Fit the two-state HMM.

```{r fit hmm_trans_2, message = FALSE}

set.seed(2023)
hmm_trans_2 <- momentuHMM::fitHMM(data=data_hmm, nbStates=nbStates,
            stateNames = c("Slow movement", "Moderate movement"),
            dist=dist,
            Par0=list(step=stepPar0,angle=kappa0),
            retryFits = 2)

```

As starting values can influence the model fit, it is advisable to fit the model with multiple starting values. This is what the argument `retryFits` achieves. To limit computation time of the tutorial, it is limited to 2, but a larger number should be used in a real analysis. 

#### 2-states with covariate effects on transition probabilities

Here, we will explore adding effect of covariates on transition probabilities. 
Define transition probability model.

```{r define hmm_trans_2 TPM model, message = FALSE}

formula = ~ preydiv # identify covariates

```

Retrieve parameters to refine the model.

```{r grab parameters hmm_trans_2, message = FALSE}

Par0_hmm_trans_2 <- momentuHMM::getPar0(hmm_trans_2, formula=formula)

```

Note: when new covariates are added to using getPar0(), the intercept coefficients are taken from the previous model, while initial value for slope coefficients are set to 0. We can see this by comparing the estimated transition probability parameters from the previous model to the initial parameters prepared for the next model with covariates.

```{r preview Par0_hmm_trans_2}
# transition probability matrix (TPM) parameters from hmm1_km
hmm_trans_2$mle$beta
# initial parameters for hmm2_km with effect of preydiv on TPM
Par0_hmm_trans_2$beta
```

Fit a refined HMM with effect of prey diversity on transition probability using estimated parameters from the initial two-state HMM.

```{r fit hmm_trans_2_refined, message = FALSE}

set.seed(2023)
hmm_trans_2_refined <- momentuHMM::fitHMM(data=data_hmm, nbStates=2,
            stateNames = c("Slow movement", "Moderate movement"),
            dist=list(step=stepDist,angle=angleDist),
            Par0=Par0_hmm_trans_2$Par,
            delta0 = Par0_hmm_trans_2$delta, 
            beta0 = Par0_hmm_trans_2$beta,
            formula=formula, retryFits = 2)

```


Visualize the results.

```{r plot hmm_trans_2_refined, message = FALSE}
plot(hmm_trans_2_refined)
```

We can see from the step-length histogram and the map that it doesn't look like this HMM is capturing the short and moderate step length movements as their own states. We can look at the pseudo-residuals of the model to confirm whether this is the case. 


```{r plot hmm_trans_2_refined pseudo-resid, warning=FALSE}
plotPR(hmm_trans_2_refined)
```

We can see in the Q-Q plot for step length (top row, middle plot), that the observed step lengths (red points) are have a higher sample quantile than predicted by the model (shaded grey area) around the theoretical quantile around 1.5. This can be interpreted as the model predicting more steps around the 1.5th theoretical quantile than there are, or in other words, that the speed of steps around the 1.5th quantile are faster than the model predicts. There is also some autocorrelation in the step length (top row, right plot) above the dotted blue line, suggesting that the latent states do not explain all the variation in observed step length. The residuals may be due to a missing state or missing effect of covariates on observation process. We will explore both of these. 


#MAM: While in the first sentence of the section only effect on the mean step length is mentionned, I think you are modifying both the mean and the sd of the step length. I think in the appendix it's just the mean step length not the sd of the step length. I would stick to just mean step length, and remove the effect on sd here.


### 3-state HMMs 

Next, we will explore adding a third state to the HMM. We start with a basic HMM without any covariates, then explore adding covariates to transition and observation probabilities.

#### Basic 3-state HMM

First, we define starting parameters for a three-state HMM.

```{r define starting parameters hmm3, message = FALSE}

# define parameters
nbStates <- 3 # number of states
stepDist <- "gamma" # step distribution
angleDist <- "vm" # turning angle distribution

mu0 <- c(5, 12, 38) # mean step length for each state
sigma0 <- c(3, 5, 8) # sd step length for each state
stepPar0 <- c(mu0, sigma0)
kappa0 <- c(0.35, 0.55, 0.5)  # turning angle for each state

```

Fit the three-state HMM.

```{r fit hmm3, message = FALSE}

set.seed(2023)
hmm_3 <- momentuHMM::fitHMM(data=data_hmm, nbStates=nbStates,
            stateNames = c("Slow movement", "Moderate movement", "Fast movement"),
            dist=list(step=stepDist,angle=angleDist),
            Par0=list(step=stepPar0,angle=kappa0), retryFits = 2)

```

Explore model

```{r}
plot(hmm_3, ask = F)
plotPR(hmm_3)
```

The predicted state map seems to adequately capture slow, moderate, and fast movement. Importantly, the ACF plots are significantly improved from previous 2-state models. Therefore, the remainder of our analysis will be built on the 3-state model.


#### 3-states with covariate effects on transition probabilities 

#MAM: I find the order of the HMM sections a bit strange. I would have put this model before (since it's the main model), and would skip the 2-state HMM with covariates in observation distribution. I think you can just say one way to deal with autocorraletion is adding another state or adding covariates in the transition prabilities (since this is a explanation of the main model), then jump to plain 3-state HMM, then come to 3-state HMM with covariates in transition, and then talk about covariates in observation probability (which is pretty minor). 

Here, we will explore adding effects of covariates on the transition probabilities. Note that this is the most typical application of covariates to HMM, and this model is the main model we focus on in the main paper.

First, define transition probability model, and retrieve parameters to refine the model. 

```{r grab parameters from hmm3, message = FALSE}

formula = ~ preydiv # identify covariates

Par0_hmm3 <- momentuHMM::getPar0(hmm_3, formula=formula)

```

Fit a refined HMM with the parameters from the initial three-state HMM.

```{r fit hmm_trans_3, message = FALSE}

set.seed(2023)
hmm_trans_3 <- momentuHMM::fitHMM(data=data_hmm, nbStates=3,
            stateNames = c("Slow movement", "Moderate movement", "Fast movement"),
            dist=list(step=stepDist,angle=angleDist),
            Par0=Par0_hmm3$Par,
            delta0 = Par0_hmm3$delta, 
            beta0 = Par0_hmm3$beta,
            formula=formula, retryFits = 2)

```

We can view the parameters and regression coefficients for the transition probabilities.

```{r print hmm_trans_3, message = FALSE}

hmm_trans_3$CIbeta

```

It's helpful to visualize the results for easier interpretation of the parameters and regression coefficients.

```{r plot hmm_trans_3, message = FALSE}
plot(hmm_trans_3)
plotPR(hmm_trans_3)
```

We can see that this three-state HMM does much better than the two-state HMM. We can see that those long step-lengths are captured in state 3, and the map of the decoded states appears to group different looking movement patterns as different states. Further, the pseudo-residual plot for step length looks much better, with the observed points in the Q-Q plot falling within the predicted Q-Q bands. As well, all the step length autocorrelation is below the blue line.

#MAM: see comments above.

The plots show that as prey diversity increases, the step length mean appears to decrease during slow movement. Mean step length does not appear to change significantly during moderate movement. Due to low frequency of travelling state, the confidence intervals of effect of prey diversity on step length mean are unreliable. 

#MAM: I think you are talking about the results of the wrong model. Here prey div is not affecting step length. It's affecting the behaviours.

There is no significant effect of prey diversity in turn angle concentration on any state. While not significant in our data set, turn angle concentration may decrease as prey diversity increases during slow movement (i.e., becomes more tortuous), and may be worth exploring with larger sample sizes. 

#MAM: same, I think you are referring to the wrong results.

Last, there is no apparent effect of prey diversity on transitions from slow movement or moderate movement. However, as prey diversity increases, there appears to be a decrease in the transition probability from travel to slow movement, an increase in transition probability from fast to moderate movement, and a peak in remaining within the travelling state when prey diversity is around 0.57. However, the overall stationary state probability distribution does not appear to vary significantly when considering all state transitions:

#MAM: I'm not sure your resulst support the last sentence. Or maybe I'm missing what you are getting at?

```{r}

statianary_est <- plotStationary(hmm_trans_3, plotCI = TRUE, return = T) # returns a list of data frames with estimated stationary state distribution and confidence intervals (useful for plotting with ggplot)

# combine into long data.frame as required by ggplot
statianary_est <- dplyr::bind_rows(statianary_est[[1]]) %>% 
  mutate(state = rep(hmm_trans_3$stateNames, each = 101))

# set colors
colours.states <- c("#99DDB6", "#539D9C", "#312C66")

# generate plot
ggplot(statianary_est, aes(x = cov, y = est, fill = state)) + 
  geom_ribbon(aes(ymin = est-se, ymax = est+se), alpha = 0.2) + 
  geom_line(aes(col = state)) +
  scale_colour_manual(values = colours.states) +
  scale_fill_manual(values = colours.states) +
  ylab("State Probability") + 
  xlab("Prey Diversity") +
  theme_minimal()
```

This plot shows that the probability of being in the slow behavior, which is often of importance for conservation because it is thought to be associated with foraging, had a positive relationship with prey diversity, the probability of being in the moderate speed behavior decreases with prey diversity, and the probability of being in fast behavior remained relatively constant with prey diversity, with a potential peak in low-medium prey diversity.


#### 3-states with covariate effects on observation probabilities

Here we allow prey diversity to influence the step length and turning angle in the observation probabilities. The covariates allowed to influence the observation probabilities are typically abiotic (e.g., snow depth), but for the sake of this tutorial, we will fit this model using prey diversity.

First we define the formulas. Here, we will focus on the effects of prey diversity on step length mean and turning angle concentration. 

```{r define models for hmm_obs_3}

stepDM <- list(mean = distFormula, sd = ~ 1) 
angleDM <- list(concentration = distFormula) 
DM <- list(step = stepDM, angle = angleDM)

```

Next we grab the parameters from our refined three-state HMM and update the model to include a design matrix (DM) for effects of covariates on distributions. 

```{r get initial parameter estimates for hmm_obs_3 from hmm_trans_3}
Par0_hmm_obs_3 <- getPar0(hmm_trans_3, DM = DM)
```

Just as when we added covariates to the transition probability, when adding new covariates to observation probabilities using getPar0(), the intercept coefficients are taken from the previous model and initial slope coefficients are set to 0. We can see this by comparing the previously estimated parameters to the initial parameters for the next model with covariates. Note that when DM is not included in the model, `momentuHMM` assumes initial parameters are on the natural scale (i.e., on the scale of how observations are measured). However, when DM is included, then initial parameters must be provided on the working scale (i.e., the scale in which the optimization occurs, between negative and positive infinity). To convert working-scale parameters to the natural scale, we must apply the inverse of the link function associated with that parameter (Table 2 in the vignette for `momentuHMM`). In the case of mean and standard deviation associated with the gamma distribution used for step length, the link function is `log()`, therefore we must apply `exp()` to convert the working scale parameters returned by `getPar0()` to the natural scale.


Fit the model.

```{r fit hmm_obs_3}
hmm_obs_3 <- momentuHMM::fitHMM(data=data_hmm, nbStates=3,
                              stateNames = c("Slow movement", "Moderate movement", "Fast movement"),
                              dist=list(step=stepDist,angle=angleDist),
                              Par0=Par0_hmm_obs_3$Par,
                              DM = DM, retryFits = 2)
```

Visualize the results. 

```{r}
plot(hmm_obs_3, ask = F, plotCI = T)
```


View parameters

```{r}
hmm_obs_3$CIbeta
```

#MAM: it would be good to add some explanations of the results here. This is I think the second model presented in the appendix. So some info here would be good.
#Maybe this from earlier: We see that when including covariates affecting the observation distributions in a 2-state model, step length of both states decreases as prey diversity increases. For both states, the turn angle concentration also decreases with prey diversity. In other words, as prey diversity increases, behaviors become slower and more tortuous. The decoded state map also looks like it's adequately distinguishing faster travelling and slower resident states. We also see that the ACF plots are  noticeably better than previous models. 




# Plots of predicted relationships with the covariate

Here we are plotting a model's estimated relationship between the resource covariate and probability of selection can be useful for general ecological inference. We will calculate the log of the relative selection strength (log-RSS) for each selection function model. The log-RSS is a measure of how likely a location (for the RSF) or step (for SSFs) is to end in a proposed location (x1) to a single reference location (x2, the mean prey diversity), where zero indicates no preference, >1 indicates selection, and <1 indicates avoidance (Avgar et al. 2017, Fieberg et al. 2021). 

First, we prepare a dataframe to predict on.
```{r prep fish}

# prep the fish data
newfish <- fish_raster %>%
  terra::as.data.frame(xy = TRUE) %>%
  filter(x > 100000 & x < 600000 & y > -550000 & y < 0)

```


## RSF

Since the RSF does not incorporate movement, we will calculate the log-RSS of the movement-free habitat selection kernel. This is easily done using `log_rss()` from `amt`.

First, we make a base dataframe to create x1 and x2 from. The values of `log_sl` and `cos_ta` do not matter, but we need populated columns in order for the `log_rss` function to work.

#MAM: if you go with using sl and ln(sl) as suggested above, you'll need to add sl_ here for the rest to work (I think)

```{r rsf log-rss prep}

base <- newfish %>% 
  mutate(log_sl = mean(data_ssf$log_sl),
         cos_ta = cos(1))

# x1 is our base dataframe
x1 <- base 

```


Next, we modify the base data frame, where prey diversity is held at its mean.

```{r rsf log-rss set constant}

x2 <- base  %>% 
  mutate(preydiv = mean(base$preydiv))

```

Now we will apply `log_rss()` to each row. Since `log_rss()` only assessed one location relative to a reference point, we will use lapply to iterate through all locations.

```{r rsf log-rss}

log_rss_list <- lapply(1:nrow(x1), function(i) {
  # Calculate log-RSS for that row
  xx <- log_rss(rsf1, x1[i,], x2[i,], ci = "se")
  # Return the element $df
  return(xx$df)
})

# combine rows
res1 <- dplyr::bind_rows(log_rss_list)

```

Visualize results.

```{r rsf log-rss plot}

# plot
line_rsf <- ggplot(res1, aes(x = preydiv_x1, y = (log_rss))) +
  geom_hline(yintercept = 0, linetype = "dashed", color = "gray") +
  geom_line(linewidth = 1, color = "#F8D59F",linetype = 2) +
  geom_ribbon(aes(ymin=lwr, ymax=upr, x=preydiv_x1), alpha = 0.4, fill = "#F8D59F") +
  xlab("Prey diversity") +
  ylab("log-RSS") +
  theme_minimal()
line_rsf

```

We see a positive relationship between prey diversity and log-RSS, which suggests that our seal is more likely to be present in areas with higher prey diversity than areas with low prey diversity. Note the bowtie shape of the standard error is due to log-RSS calculating selection strength relative to a starting step, in this case, where prey diversity is set to its mean.


## SSF

We can also calculate the log-RSS for our SSFs following the same workflow as for the RSF. Since log_rss() passes to predict(), it is important that the fit SSF includes `model = TRUE`. 

First, we will calculate log-RSS for ssf1. Again, since `log_rss()` only assesses one location relative to a reference point, we will use lapply to iterate through all locations, and bind the rows together after so that we have a single data frame for plotting.

```{r ssf1 log-rss}

## log-RSS prediction for ssf1
# apply log_rss() to each row
log_rss_list <- lapply(1:nrow(x1), function(i) {
  # Calculate log-RSS for that row
  xx <- log_rss(ssf1, x1[i,], x2[i,], ci = "se")
  # Return the element $df
  return(xx$df)
})

# combine rows
res2 <- dplyr::bind_rows(log_rss_list) %>%
  mutate(Speed = "without int.")

```

Visualize results.

```{r ssf1 log-rss plot}

line_ssf1 <- ggplot() +
  geom_hline(yintercept = 0, linetype = "dashed", color = "grey") +
  geom_line(data = res2, aes(x = preydiv_x1, y = log_rss, color = Speed, group = Speed), size = 1, linetype = 3, color = "black") + 
  geom_ribbon(data = res2, aes(ymin=lwr, ymax=upr, x=preydiv_x1, fill = Speed, group = Speed), alpha = 0.3, fill = "black") +
  xlab("Prey diversity") +
  ylab("log-RSS") +
  theme_minimal()
line_ssf1

```

We see no relationship between prey diversity and log-RSS, which suggests that our seal is similarily likely to be present in areas with higher prey diversity and areas with low prey diversity.

Now we will calculate log-RSS for ssf2. We will estimate the log-RSS for three different step-lengths (slow, moderate, fast). We set these speeds as the 25th, 50th, and 75th percentiles of step-length, then loop the log-RSS for each speed. First, identify what the percentiles are.

```{r ssf2 log-rss prep}

# determine the 25th (slow), 50th (moderate), and 75th (fast) percentiles of step-length
nums <- seal %>%
  make_track(lon, lat, date) %>%
  steps %>%
  mutate(log_sl = log(sl_)) %>%
  dplyr::reframe(quants = quantile(log_sl, c(0.25, 0.5, 0.75))) %>%
  pull()

```

Now apply log-RSS to each row, for each speed (step length percentile).

```{r ssf2 log-rss}

# set-up to run function for each speed
results_ssf2 <- lapply(nums, function(j) {
x1$log_sl <- j

# calculate log-RSS
  log_rss_list <- lapply(1:nrow(x1), function(i) {
    # Calculate log-RSS for that row
    xx <- log_rss(ssf2, x1[i,], x2[i,], ci = "se")
    # Return the element $df
    return(xx$df)
  })
  # bind rows within each speed's prediction
  res3 <- dplyr::bind_rows(log_rss_list)
} )

```

Bind the output together, and name the step lengths based on how long they are, so that we can interpret them in the subsequent plot as different speeds.

```{r ssf2 log-rss bind}

results_ssf2 <- dplyr::bind_rows(results_ssf2) %>%
  mutate(log_sl_x1 = as.factor(round(log_sl_x1,1)),
         Speed = dplyr::case_when(as.factor(log_sl_x1) == '8.4' ~ "Slow",
                                  as.factor(log_sl_x1) == "9.2" ~ "Moderate",
                                  as.factor(log_sl_x1) == "9.6" ~ "Fast"))

```

Visualize results.

```{r ssf2 log-rss plot}

line_ssf2 <- ggplot(results_ssf2, aes(x = preydiv_x1, y = (log_rss))) +
  geom_hline(yintercept = 0, linetype = "dashed", color = "gray") +
  geom_line(size = 1, aes(color = Speed, group = Speed, linetype = Speed)) +
  geom_ribbon(aes(ymin=lwr, ymax=upr, x=preydiv_x1, fill = Speed, group = Speed), alpha = 0.3) +
  scale_colour_manual(values=c(colours.states,"#000000")) +
  scale_fill_manual(values=c(colours.states,"#000000")) +
  scale_linetype_manual(values = c("solid", "solid", "solid")) +
  xlab("Prey diversity") +
  ylab("log-RSS") +
  theme_minimal()
line_ssf2

```

We can see a weak positive relationship between prey diversity and log-RSS, however, with confidence intervals (shading) covering zero, suggesting no significant relationship between prey diversity and log-RSS. We also see that the confidence intervals cover each other, suggesting that different speeds do not have different relationships between prey diversity and log-RSS.

Typically these models would be interpreted independently. But it's worth noting that while the effects are minimal and the confidence intervals overlap, when comparing ssf1 and ssf2, ssf2 provides more information about the animal's relationship with prey diversity.

```{r ssf 1 and 2 log-rss plot, message = 'false'}

ggplot(results_ssf2, aes(x = preydiv_x1, y = (log_rss))) +
  geom_hline(yintercept = 0, linetype = "dashed", color = "gray") +
  geom_line(size = 1, aes(color = Speed, group = Speed, linetype = Speed)) +
  geom_ribbon(aes(ymin=lwr, ymax=upr, x=preydiv_x1, fill = Speed, group = Speed), alpha = 0.3) +
  xlab("Prey diversity") +
  ylab("log-RSS") +
  theme_minimal() +
  geom_hline(yintercept = 0, linetype = "dashed", color = "gray") +
  geom_line(data = res2, aes(x = preydiv_x1, y = log_rss, color = Speed, group = Speed, linetype = Speed), size = 1) + 
  geom_ribbon(data = res2, aes(ymin=lwr, ymax=upr, x=preydiv_x1, fill = Speed, group = Speed), alpha = 0.2) +
  scale_color_manual(values = c("#99DDB6", "#539D9C", "#312C66", "black"), 
                     labels = c("Fast", "Moderate", "Slow", "Not consid."), 
                     name = "Speed") +
  scale_fill_manual(values = c("#99DDB6", "#539D9C", "#312C66", "black"), 
                     labels = c("Fast", "Moderate", "Slow", "Not consid."), 
                     name = "Speed") +
  scale_linetype_manual(values = c("solid", "solid", "solid", "dotted"), 
                     labels = c("Fast", "Moderate", "Slow", "Not consid."), 
                     name = "Speed") 
  
```

Here, we see that adding the interaction between prey diversity and step length did not better explain our data or provide additional ecological insight about our seal.

## HMM

Exploring the insight on the relationship between our seal and prey diversity is fundamentally different for the HMM. Here, we will grab and plot the stationary state probabilities. This is easily done using `plotStationary()` from `momentuHMM`.

```{r hmm grab stationaries, fig.show='hide'}

# grab stationary probabilities
ps <- momentuHMM::plotStationary(hmm_trans_3, plotCI= TRUE, return = TRUE)

# grab values for data frame
state1 <- ps$preydiv$'Slow movement' %>% mutate(state = 1)
state2 <- ps$preydiv$'Moderate movement' %>% mutate(state = 2)
state3 <- ps$preydiv$'Fast movement' %>% mutate(state = 3)

# bind to one data frame
pdat <- rbind(state1, state2, state3) %>%
  mutate(state = as.character(state))

```

Visualize results.

```{r hmm stationary plot}

line_hmm <- ggplot() + 
  geom_line(data = pdat, aes(x = cov, y = est, color = state)) +
  geom_ribbon(data = pdat, aes(x=cov, y=est, ymax=est+se, ymin=est-se, fill = state), 
              alpha = 0.4, show.legend = TRUE) +
  ylab("State probabilty") +
  xlab("Prey diversity") +
  scale_color_manual(values = c("#99DDB6", "#539D9C", "#312C66"), name = "HMM state",
                     labels=c("Slow movement", "Moderate movement", "Fast movement")) +
    scale_fill_manual(values = c("#99DDB6", "#539D9C", "#312C66"), name = "HMM state",
                     labels=c("Slow movement", "Moderate movement", "Fast movement")) +
  theme_minimal()

line_hmm

```

Here we can see that each state has a different relationship between the stationary state probability and prey diversity. The slow movement state has a positive relationship between stationary state probability and prey diversity, the moderate movement state has a negative relationship with prey diversity, and the fast movement state does not appear to have a directional relationship with prey diversity.


# Prediction maps

Now we will estimate the utilization distributions from each model to demonstrate how differences in the relationships with a covariate can results in vastly different spatial patterns. The utilization distribution is defined as the two-dimensional relative frequency distribution of space use of an animal (Van Winkle 1975). This is a simple calculation for the RSF, where we multiply the model coefficient with the resource (prey diversity), exponentiate (since it is a logistic regression), and normalize the estimate. The calculations are more complex for the SSFs since they are conditional models that integrate the movement process. Thus, for the SSFs we calculate the steady-state utilization distribution (SSUD), which is the long-term expectation of the space-use distribution across the landscape (Signer et al. 2017). `amt` has functions to estimate the SSUD.


## RSF

We can predict the estimated probability of use from the RSF by hand. First, grab the model coefficients and predict for each cell.
```{r rsf prediction}

# grab model coefficients
modcoef <- summary(rsf1)$coef

# prediction for each cell
x <- exp(modcoef[2] * newfish$preydiv)

```

We will normalize the results next.
```{r rsf prediction normalization}

# range fn
range01 <- function(x){(x-min(x))/(max(x)-min(x))}

# set the range from zero to one
newfish$rsf_prediction <- range01(x)

```

Visualize results.
```{r rsf prediction map}

map_rsf <- ggplot() + 
  geom_tile(data = newfish, aes(x = x,y = y, fill = rsf_prediction)) +
  scale_fill_viridis(option = "mako", name = "RSF prediction",limits = c(0,1)) +
  geom_sf(data = nat_trans, fill = "grey80", color = "white") + 
  coord_sf(xlim = ext(fish_raster)[1:2], ylim = ext(fish_raster)[3:4], expand = F) +
  theme_void()
map_rsf

```

## SSF

We can use the `amt` functions to estimate the SSUDs from the simple SSF that does not allow prey diversity to affect the movement kernel. When estimating the SSUDs, the functions require that covariates are specifically labelled as occuring at the end of the step (i.e., `preydiv_end`). This is easily implemented by specifying `where = "both"` when using `extract_covariates`, which will then produce a column for `preydiv_start` and `preydiv_end`. By default, as in our initial fitting, `extract_covariates` extracts data for the end of the step, but does not record the `_start` or `_end` suffix. Thus, we are re-extracting covariates for ease throughout the generation of the SSUDs.


```{r ssf1 refit}
# generate availability sample
set.seed(2023)
data_ssf <- seal %>%
  mutate(date = as.POSIXct(date)) %>%
  make_track(lon, lat, date) %>%
  steps() %>%
  random_steps() %>% 
  arrange(case_) %>%
  amt::extract_covariates(fish_raster, where = "both")

# fit SSF1 model
m1 <- data_ssf |> 
  fit_clogit(case_ ~ preydiv_end +  log(sl_) + cos(ta_) + 
               strata(step_id_))
```

Now we will set the starting position for the simulation.

```{r ssf1 set start}

start <- make_start((seal %>%
                       mutate(date = as.POSIXct(date)) %>%
                       make_track(lon, lat, date))[1,])
```

We can also set constants for how many steps we want to simulate. Additionally, we set a burn-in number of steps, where we later remove this number of steps from the simulated path to reduce the influence of the starting point.

```{r ssf1 set constants}

n_steps = 1e4 # number of steps
burnin <- n_steps/50 # number of steps to remove for the burn-in

```

Generate the redistribution kernel. 

```{r ssf1 set redistribution kernel}

k1 <- redistribution_kernel(m1, map = fish_raster, start = start,
                            stochastic = TRUE,
                            tolerance.outside = 1,
                            n.control = n_steps)

```

Simulate the path. This function will likely take about five minutes on most laptops. As such, I have added the resulting simulated paths `/data/p1_1e4` Feel free to uncomment the `read.csv` line to load it in instead of running the `simulate_path` if prefered. Additionally, I have also ran the simulation with 1e5 steps. This takes about 12 hours to run, so we will not use those data here, but this can be loaded as `/data/p1_1e4`. Our plots in the main paper use 1e5 steps.

```{r ssf1 simulate path}

set.seed(2023)
p1 <- amt::simulate_path(x = k1, n = n_steps, start = start, verbose = TRUE)

#p1 <- read.csv(here("data/p1_1e4.csv")) %>% as_tibble()

```

Remove the burn-in.

```{r ssf1 remove burnin}

p1_burnt <- p1 %>% dplyr::slice(-c(1:burnin))

```

Visualize the simulated path.

```{r ssf1 plot simulation}

ssf_track_1 <- fishmap +
  geom_sf(data = nat_trans, fill = "grey80", color = "white") + 
  geom_point(data = p1_burnt, aes(x = x_,y = y_), alpha = 0.61) +
  geom_path(data = p1_burnt, aes(x = x_,y = y_)) +
  coord_sf(xlim = ext(fish_raster)[1:2], ylim = ext(fish_raster)[3:4], expand = F) +
  theme_void()
ssf_track_1

```

We will use this track to estimate the SSUD. We will convert the estimated SSUD to a data frame for easy plotting.

```{r ssf1 ssud plot prep}

uds_ssf1 <- tibble(rep = 1:nrow(p1_burnt), 
    x_ = p1_burnt$x_, y_ = p1_burnt$y_,
    t_ = p1_burnt$t_, dt = p1_burnt$dt) %>%
  filter(!is.na(x_)) %>%
  make_track(x_, y_) %>% 
  hr_kde(trast = fish_raster, which_min = "global") %>%
  hr_ud() %>% 
  terra::as.data.frame(xy = TRUE)

```

Visualize the results.

```{r ssf1 ssud plot}

map_ssf1 <- ggplot() + 
  geom_tile(data = uds_ssf1, aes(x = x,y = y, fill = preydiv)) +
  scale_fill_viridis(option = "mako", name = "SSF1 prediction") +
  geom_sf(data = nat_trans, fill = "grey80", color = "white") + 
  coord_sf(xlim = ext(fish_raster)[1:2], ylim = ext(fish_raster)[3:4], expand = F) +
  theme_void()
map_ssf1

```

The map shows that probability of use is fairly generally distributed in space.

We will follow the same steps to generate a SSUD for the SSF that allows prey diversity to affect the movement kernel.

```{r ssf2 refit}

m2 <- data_ssf %>%
  fit_clogit(case_ ~ preydiv_end * log(sl_) + cos(ta_) + 
               strata(step_id_))

```

Generate the redistribution kernel. 

```{r ssf2 redistribution kernel}

set.seed(2023)
k2 <- redistribution_kernel(m2, map = fish_raster, start = start,
                            stochastic = TRUE,
                            tolerance.outside = 1,
                            n.control = n_steps)

```

Simulate the path. Similar to SSF1, this function may take some time to run. I have stored the simulated path with 1e5 locations in `data/p2_1e4`, or for the full simulation, `data/p2_1e5`, for loading in here if you prefer not to run it on your own computer.

```{r ssf2 simulation}

set.seed(2023)
p2 <- amt::simulate_path(x = k2, n = n_steps, start = start, verbose = TRUE) 
#p2 <- read.csv(here("data/p2_1e4.csv")) %>% as_tibble()

```

Remove burn-in. 

```{r ssf2 burnin}

p2_burnt <- p2 %>% dplyr::slice(-c(1:burnin))

```

Visualize simulated track. 

```{r ssf2 plot track}

ssf_track_2 <- fishmap +
  geom_sf(data = nat_trans, fill = "grey80", color = "white") + 
  geom_point(data = p2_burnt, aes(x = x_,y = y_), alpha = 0.61) +
  geom_path(data = p2_burnt, aes(x = x_,y = y_)) +
  coord_sf(xlim = ext(fish_raster)[1:2], ylim = ext(fish_raster)[3:4], expand = F) +
  theme_void()
ssf_track_2

```

Estimate the SSUD. 

```{r ssf2 estimate SSUD}

uds_ssf2 <- tibble(rep = 1:nrow(p2_burnt), 
    x_ = p2_burnt$x_, y_ = p2_burnt$y_,
    t_ = p2_burnt$t_, dt = p2_burnt$dt) |> 
  filter(!is.na(x_)) |> 
  make_track(x_, y_) |> 
  hr_kde(trast = fish_raster, which_min = "global") %>%
  hr_ud() %>% 
  terra::as.data.frame(xy = TRUE)

```

Visualize the SSUD. 

```{r ssf2 plot SSUD}

map_ssf2 <- ggplot() + 
  geom_tile(data = uds_ssf2, aes(x = x,y = y, fill = preydiv)) +
  scale_fill_viridis(option = "mako", name = "SSF2 prediction") +
  geom_sf(data = nat_trans, fill = "grey80", color = "white") + 
  coord_sf(xlim = ext(fish_raster)[1:2], ylim = ext(fish_raster)[3:4], expand = F) +
  theme_void()
map_ssf2

```

## HMM

We will first estimate the stationary state probabilities of each state based on prey diversity. This is easily done using the `momentuHMM` function `stationary()`. This function predicts the probability of being in each state given a covariate (prey diversity).

```{r hmm prediction for map}

x <- as.data.frame(momentuHMM::stationary(hmm_trans_3, 
                   data.frame(preydiv = newfish$preydiv)))
newfish$hmm_state1 <- x$Slow.movement
newfish$hmm_state2 <- x$Moderate.movement
newfish$hmm_state3 <- x$Fast.movement

```

Format the data for plotting.

```{r hmm prediction data format}

newfish_long <- newfish %>%
  tidyr::pivot_longer(cols = hmm_state1:hmm_state3, 
               names_to = "model", values_to = "prediction") %>%
  mutate(dplyr::across(model, factor, levels=
               c("hmm_state1", "hmm_state2", "hmm_state3")))

```

Visualize the results.

```{r hmm prediction plot}

map_hmm <- ggplot() + 
  geom_tile(data = newfish_long, aes(x = x, y = y, fill = prediction)) +
  scale_fill_viridis(option = "mako", limits = c(0,1)) +
  labs(fill = 'HMM predicted\nprobability') +
   geom_sf(data = nat_trans, fill = "grey80", color = "white") + 
  coord_sf(xlim = ext(fish_raster)[1:2], ylim = ext(fish_raster)[3:4], expand = F) +
  facet_wrap(~model, labeller = as_labeller(c('hmm_state1' = "Slow movement",
                                              'hmm_state2' = "Moderate movement",
                                              'hmm_state3' = "Fast movement"))) +
  theme_void()

map_hmm

```

We can see that the slow movement state, which was positively related to prey diversity, showed a similar restricted spatial pattern to the RSF, whereas the moderate movement state, which had a negative relationship with prey diversity, showed the opposite pattern to the RSF prediction map. The fast movement state did not show as much spatial variation, due to its non significant relationship with prey diversity.

# References 

<div style="text-indent: -40px; padding-left: 40px;"> Avgar, T., Lele, S. R., Keim, J. L., & Boyce, M. S. (2017). Relative selection strength: Quantifying effect size in habitat‐and step‐selection inference. Ecology and Evolution, 7(14).  5322-5330.https://doi.org/10.1002/ece3.3122 </div>


<div style="text-indent: -40px; padding-left: 40px;">
Fieberg, J., Signer, J., Smith, B., & Avgar, T. (2021). A ‘How to’guide for interpreting parameters in habitat‐selection analyses. Journal of Animal Ecology, 90(5), 1027-1043. https://doi.org/10.1111/1365-2656.13441 </div>


<div style="text-indent: -40px; padding-left: 40px;">
Florko, K.R.N., Tai, T.C., Cheung, W.W.L., Sumaila, U.R., Ferguson, S.H., Yurkowski, D.J., Auger-Méthé, M. (2021). Predicting how climate change threatens the prey base of Arctic marine predators. Ecology Letters, 24: 2563-2575. https://doi.org/10.1111/ele.13866 </div>


<div style="text-indent: -40px; padding-left: 40px;">
Florko, K.R.N., Tai, T.C., Cheung, W.W.L., Sumaila, U.R., Ferguson, S.H., Yurkowski, D.J., Auger-Méthé, M. (2021b), Predicting how climate change threatens the prey base of Arctic marine predators, Dryad, Dataset, https://doi.org/10.5061/dryad.x69p8czjs </div>


<div style="text-indent: -40px; padding-left: 40px;">
Florko, K.R.N., Shuert, C.R., Cheung, W.W.L., Ferguson, S.H., Jonsen, I.D., Rosen, D.A.S., Sumaila, U.R., Tai, T.C., Yurkowski, D.J., Auger-Méthé, M. (2023). Linking movement and dive data to prey distribution models: new insights in foraging behavior and potential pitfalls of movement analyses. Movement Ecology, 11:17 https://doi.org/10.1186/s40462-023-00377-2 </div>


<div style="text-indent: -40px; padding-left: 40px;">
McClintock, B.T., Michelot, T. (2018). momentuHMM: R package for generalized hidden markov models of animal movement. Methods in Ecology and Evolution, 9, 1518-1530.  https://doi.org/10.1111/2041-210X.12995 </div>


<div style="text-indent: -40px; padding-left: 40px;">
Signer, J., Fieberg, J., & Avgar, T. (2017). Estimating utilization distributions from fitted step‐selection functions. Ecosphere, 8(4), e01771.   https://doi.org/10.1002/ecs2.1771 </div>


<div style="text-indent: -40px; padding-left: 40px;">
Signer, J., J. Fieberg, and T. Avgar. (2019). Animal movement tools (amt): R package for managing tracking data and conducting habitat selection analyses. Ecology and Evolution, 9:880–890.  https://doi.org/10.1002/ece3.4823 </div>


<div style="text-indent: -40px; padding-left: 40px;"> Van Winkle, W. (1975). Comparison of several probabilistic home-range models. The Journal of wildlife Management, 118-123. https://doi.org/10.2307/3800474 </div>

# Session

```{r}
sessioninfo::session_info()
```

