---
title: "Appendix 3"
author: "Katie Florko"
date: "30/11/2022"
output: html_document
theme: cosmo
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# Overview

This document contains the code from "*A comparison of statistical models used to characterize species-habitat associations with movement data*". This code includes the case study analysis on ringed seal movement in eastern Hudson Bay, Canada.

# Prepare
## Load packages

```{r, message = FALSE, warning = FALSE}
library(tidyverse)
library(ggplot2)
library(lubridate)
library(rnaturalearth)
library(rgdal)
library(terra)
library(amt)
library(momentuHMM)
library(viridis)
library(sf)
library(here)
```

## Fish data

Next we load in the fish data. This is a subset of the data from Florko et al. (2021).
```{r}

# load fish data
fish <- read.csv(here("data/preydiv.csv"))
head(fish)

```


Visualize the fish data.
```{r, message = FALSE}

#prepare world data
## List of azimuthal equal area - HudsonBay 
natearth <- ne_countries(scale = "medium",returnclass = "sp")
natearth <- natearth[which(natearth$continent!="Antarctica"),]
nat_trans <- spTransform(natearth,CRS("+proj=laea +lat_0=60 +lon_0=-85 +x_0=0 +y_0=0 +datum=WGS84 +units=m +no_defs +ellps=WGS84 +towgs84=0,0,0"))

# plot fish map
fishmap <- ggplot() + 
  geom_tile(data = fish, aes(x = lon,y = lat,fill = preydiv)) +
  scale_fill_viridis(option = "mako", limits = c(0.5, 0.75), name = "Prey\ndiversity") +
  geom_polygon(data = nat_trans, aes(x=long,y=lat,group=group), fill = "grey80", color = "white") +
  coord_cartesian(xlim = c(150000,550000), ylim = c(-500000,-50000), expand = F) 
fishmap
```


## Seal data

Next we load in the seal movement data. This is a subset of the data from Florko et al. (2023).
```{r, message = FALSE}

seal <- read.csv(here("data/seal_track_m.csv")) 
head(seal)

# ensure the data is in the correct format
seal <- seal %>%
  mutate(id = as.character(id),
         date = as.Date(date)) 
```

Visualize the seal data on top of the fish data.
```{r}

# plot
sealfishmap <- fishmap + 
  geom_point(data=seal, aes(x=lon, y=lat), alpha = 0.6, color = "#FCEEAE") + 
  geom_path(data=seal, aes(x=lon, y=lat), color = "#FCEEAE") 

sealfishmap

```
# Fit models
#1. RSF
Fit using amt (Signer et al. 2019)
```{r}
# generate availability sample
set.seed(2023)
data_rsf <- seal %>%
  make_track(lon, lat, date) %>%
  random_points() # default is ten times as many available points as observed points

# plot used vs available locations
sealfishmap +
  geom_point(data=data_rsf, aes(x=x_, y=y_, color = case_), alpha = 0.6) +
  scale_color_manual(values = c("black", "#FCEEAE"), 
                     label = c("Available", "Observed"), name = "Data type") 

# rasterize and extract prey diversity covariate
fish_raster <- terra::rast(fish, crs = "+proj=longlat +ellps=WGS84 +datum=WGS84 +no_defs")

data_rsf <- data_rsf %>%
  amt::extract_covariates(fish_raster)

# fit rsf
rsf1 <- data_rsf %>%
  amt::fit_rsf(case_ ~ preydiv, model = TRUE)

# see parameter estimates
summary(rsf1)
```


#2. SSF
Fit using amt (Signer et al. 2019)
```{r, message = FALSE}

# generate availability sample
set.seed(2023)
data_ssf <- seal %>%
  make_track(lon, lat, date) %>%
  steps() %>%
  random_steps() %>% # default is ten times as many available points as observed points
  arrange(case_)

# plot used vs available locations
sealfishmap +
  geom_point(data=data_ssf, aes(x=x2_, y=y2_, color = case_), alpha = 0.6) +
  scale_color_manual(values = c("black", "#FCEEAE"), 
                     label = c("Available", "Observed"), name = "Data type") 

# extract prey diversity covariate
data_ssf <- data_ssf %>%
  extract_covariates(fish_raster, where = "end") #sample at end of step

# transform movement covariates
data_ssf <- data_ssf %>%
  mutate(cos_ta = cos(ta_),
         log_sl = log(sl_))

# fit ssfs
## ssf1: ssf without covariate affecting movement kernel
ssf1 <- data_ssf %>%
  fit_clogit(case_ ~ preydiv + log_sl + cos_ta + strata(step_id_), model = TRUE)

## ssf2: ssf with covariate affecting movement kernel
ssf2 <- data_ssf %>%
  fit_clogit(case_ ~ log_sl * preydiv + cos_ta * preydiv + strata(step_id_), model = TRUE)

# see parameter estimates
summary(ssf1)
summary(ssf2)
```



#3. HMM
Fit using momentuHMM (McClintock and Michelot, 2018)
```{r, message = FALSE}
# prepare dataset
data_hmm <- seal %>%
  make_track(lon, lat, date) %>%
  extract_covariates(fish_raster) %>%
  mutate(ID = 1,
         x = x_,
         y = y_,
         date = t_) %>%
  dplyr::select(ID, x, y, date, preydiv) %>%
  as.data.frame()

# convert into momentuHMM format
data_hmm <- momentuHMM::prepData(data_hmm, coordNames = c("x", "y"), 
                                 type = "UTM",
                                 covNames = c("preydiv"))

# define initial parameters
nbStates <- 3 # number of states
stepDist <- "gamma" # step distribution
angleDist <- "vm" # turning angle distribution

mu0 <- c(5000, 18000, 38000) # mean step length for each state
sigma0 <- c(5000,  10000, 10000) # sd step length for each state
stepPar0 <- c(mu0, sigma0) 
kappa0 <- c(0.35, 0.55, 0.5) # turning angle for each state

formula = ~ preydiv # identify covariates

# fit basic 3-state hmm
set.seed(2023)
hmm1 <- momentuHMM::fitHMM(data=data_hmm, nbStates=nbStates,
            dist=list(step=stepDist,angle=angleDist),
            Par0=list(step=stepPar0,angle=kappa0))

# retrieve parameters to refine model
Par0_hmm1 <- momentuHMM::getPar0(hmm1, formula=formula)

# fit a refined hmm with parameters from hhm1
set.seed(2023)
hmm2 <- momentuHMM::fitHMM(data=data_hmm, nbStates=3,
            dist=list(step=stepDist,angle=angleDist),
            Par0=Par0_hmm1$Par,
            delta0 = Par0_hmm1$delta, 
            beta0 = Par0_hmm1$beta,
            formula=formula)

# plot decoded states
data_hmm$state <- as.factor(momentuHMM::viterbi(hmm2))
hmmstate_plot <- ggplot() + 
  scale_fill_viridis(option = "mako", limits = c(0.5, 0.75), name = "Prey\ndiversity") +
  geom_path(data=data_hmm, aes(x=x, y=y, color = state, group =ID)) + 
  geom_point(data=data_hmm, aes(x=x, y=y, color = state, shape = state), size=2, alpha = 0.8) + 
  scale_color_manual(values = c("#99DDB6", "#539D9C", "#312C66"), 
                     labels = c("Localized\nsearch", "Area-restricted\nsearch", "Travelling"), 
                     name = "HMM state") +
  scale_shape_manual(values = c(15, 16, 17), 
                     labels=c("Localized\nsearch", "Area-restricted\nsearch", "Travelling"), 
                     name = "HMM state") +
  geom_polygon(data = nat_trans, aes(x=long,y=lat,group=group), fill = "grey80", color = "white") +
  coord_cartesian(xlim = c(150000,550000), ylim = c(-500000,-50000), expand = F)
hmmstate_plot


#---------------------PLOT HISTOGRAMS

## prep data in lat/lon and refit model (so step length is in kilometers)
data_hmm <- seal %>%
  make_track(lon, lat, date) %>%
  extract_covariates(fish_raster) %>%
    mutate(ID = 1,
         x = x_,
         y = y_,
         date = t_) %>%
  dplyr::select(ID, x, y, date, preydiv) %>%
  as.data.frame() %>%
  st_as_sf(coords = c("x", "y")) %>%
  st_set_crs("+proj=laea +lat_0=60 +lon_0=-85 +x_0=0 +y_0=0 +datum=WGS84 +units=m +no_defs +ellps=WGS84 +towgs84=0,0,0") %>%
  st_transform("+proj=longlat +datum=WGS84") %>%
  mutate(long = unlist(map(geometry,1)),
          lat = unlist(map(geometry,2))) %>%
  st_drop_geometry()

# do momentuhmm which calculates step length in KM
data_hmm <- momentuHMM::prepData(data_hmm, coordNames = c("long", "lat"), type = "LL", covNames = c("preydiv"))

hist(data_hmm$step)

# define parameters
nbStates <- 3
stepDist <- "gamma" # step distribution
angleDist <- "vm" # turning angle distribution

mu0 <- c(5, 12, 38)
sigma0 <- c(3, 5, 8)
stepPar0 <- c(mu0, sigma0)
kappa0 <- c(0.35, 0.55, 0.5)

set.seed(2023)
hmm1_km <- momentuHMM::fitHMM(data=data_hmm, nbStates=nbStates,
            dist=list(step=stepDist,angle=angleDist),
            Par0=list(step=stepPar0,angle=kappa0))

# get starting parameters 
Par0_hmm1_km <- momentuHMM::getPar0(hmm1_km, formula=formula)

# fit hmm with formula
set.seed(2023)
hmm2_km <- momentuHMM::fitHMM(data=data_hmm, nbStates=3,
            dist=list(step=stepDist,angle=angleDist),
            Par0=Par0_hmm1_km$Par,
            delta0 = Par0_hmm1_km$delta, 
            beta0 = Par0_hmm1_km$beta,
            formula=formula)

# add the state estimate from the HMM
data_hmm$state <- as.factor(momentuHMM::viterbi(hmm2_km))


##-----STEP DIST histogram

#calculate frequencies of states
v <- momentuHMM::viterbi(hmm2_km)
stateFreq <- table(v) / length(v)

#plot colours
colours.states <- c("#99DDB6", "#539D9C", "#312C66")

#generate sequence for x axis of density functions
x <- seq(0, 50, length=1000)

#get converged mean and sd for each state 
meanARS <- hmm2_km$mle$step[1,1]  
sdARS <- hmm2_km$mle$step[2,1]    

meanCR <- hmm2_km$mle$step[1,2]    
sdCR <- hmm2_km$mle$step[2,2]     

meanTR <- hmm2_km$mle$step[1,3]    
sdTR <- hmm2_km$mle$step[2,3]    

#calculate shape and scale of the gamma distributions from mean and sd
sh <- function(mean, sd) { return(mean^2 / sd^2)}
sc <- function(mean, sd) { return(sd^2 / mean)}

#get density functions of the distributions
y_ARS <- dgamma(x, shape=sh(meanARS,sdARS),  scale=sc(meanARS,sdARS)) * stateFreq[[1]]
y_CR <- dgamma(x, shape=sh(meanCR,sdCR),  scale=sc(meanCR,sdCR)) * stateFreq[[2]]
y_TR <- dgamma(x, shape=sh(meanTR,sdTR),  scale=sc(meanTR,sdTR)) * stateFreq[[3]]


#combine densities in a single dataframe for more convenient plotting
df.y_ARS <- data.frame(dens=y_ARS, State="Foraging", x=x)
df.y_CR <- data.frame(dens=y_CR,  State="ARS", x=x)
df.y_TR <- data.frame(dens=y_TR,  State="Travelling", x=x)
statedis <- rbind(df.y_ARS, df.y_CR, df.y_TR)

#plot distributions
hmmstepdist_plot <- ggplot() +
  geom_line(data=statedis,aes(x=x,y=dens,colour=State,linetype=State), size=1.2) +
  scale_colour_manual(values=c(colours.states,"#000000"), 
              breaks = c('Foraging', 'ARS', 'Travelling'), 
              labels=c("Localized\nsearch", "Area-restricted\nsearch", "Travelling")) +
  scale_linetype_manual(values=c("solid","solid", "solid"), 
              breaks = c('Foraging', 'ARS', 'Travelling'), 
              labels=c("Localized\nsearch", "Area-restricted\nsearch", "Travelling")) +
  ylab("Density") + 
  xlab("Step length (kms)") 
hmmstepdist_plot

##-----ANGLE DIST
# #generate sequence for x axis of density functions
x <- seq(-pi, pi,length=1000)

#get converged mean and concentration for each state 
meanARS <- hmm2_km$mle$angle[1,1]  
sdARS <- hmm2_km$mle$angle[2,1]    

meanCR <- hmm2_km$mle$angle[1,2]    
sdCR <- hmm2_km$mle$angle[2,2]  

meanTR <- hmm2_km$mle$angle[1,3]    
sdTR <- hmm2_km$mle$angle[2,3]  

#get density functions of the distributions
y_ARS <- CircStats::dvm(x, mu=meanARS,  kappa=sdARS) * stateFreq[[1]]
y_CR <- CircStats::dvm(x, mu=meanCR,  kappa=sdCR) * stateFreq[[2]]
y_TR <- CircStats::dvm(x, mu=meanTR,  kappa=sdTR) * stateFreq[[3]]


#combine densities in a single dataframe for more convenient plotting
df.y_ARS <- data.frame(dens=y_ARS, State="Foraging",x=x)
df.y_CR <- data.frame(dens=y_CR,  State="ARS",x=x)
df.y_TR <- data.frame(dens=y_TR,  State="Travelling",x=x)

cmb <- rbind(df.y_TR, df.y_CR, df.y_ARS)

#plot distributions
hmmangledist_plot <- ggplot() +
  geom_line(data=cmb,aes(x=x,y=dens,colour=State), size = 1.2) +
  scale_colour_manual(values=c(colours.states), breaks = c('Foraging', 'ARS', 'Travelling'), labels=c("Localized\nsearch", "Area-restricted\nsearch", "Travelling")) +
  scale_x_continuous(limits=c(-pi,pi))+
  ylab("Density") + 
  xlab("Turn angle (radians) ") 
hmmangledist_plot
```

# Plot prediction maps
Prep the data
```{r}
# prep the fish data
newfish <- fish_raster %>%
  terra::as.data.frame(xy = TRUE) %>%
  filter(x > 100000 & x < 600000 & y > -550000 & y < 0)

```


#1. RSF
```{r}

modcoef <- summary(rsf1)$coef
x <- exp(modcoef[1] + (modcoef[2] * newfish$preydiv))
x <- x / (1 + x)

# range fn
range01 <- function(x){(x-min(x))/(max(x)-min(x))}
newfish$rsf_prediction <-range01(x)

# plot
map_RSF <- ggplot() + 
  geom_tile(data = newfish, aes(x = x,y = y, fill = rsf_prediction)) +
  scale_fill_viridis(option = "mako", name = "RSF prediction", limits = c(0, 0.3)) +
  geom_polygon(data = nat_trans, aes(x=long,y=lat,group=group), fill = "grey80", color = "white") +
  coord_cartesian(xlim = c(150000,550000), ylim = c(-500000,-50000), expand = F) 
map_RSF

```

#2. SSF

```{r}

# generate availability sample
set.seed(2023)
data_ssf <- seal %>%
  mutate(date = as.POSIXct(date)) %>%
  make_track(lon, lat, date) %>%
  steps() %>%
  random_steps() %>% 
  arrange(case_) %>%
  amt::extract_covariates(fish_raster, where = "both") %>%
  na.omit() 

### -------------- SSF1
# fit SSF1 model
m1 <- data_ssf |> 
  fit_clogit(case_ ~ preydiv_end +  cos(ta_) + log(sl_) + 
              # add terms for home range
               x2_ + y2_ + I(x2_^2 + y2_^2) +
               strata(step_id_))
summary(m1)



# Start with simulations
# First generate a redistribution kernel
set.seed(2023)
start <- make_start((seal %>%
                       mutate(date = as.POSIXct(date)) %>%
                       make_track(lon, lat, date))
                          # random sample along the track as the start
                          [sample(1:nrow(seal), 1), ], 
                    dt_ = hours(2)) 

# generate redistribution kernel
k1 <- redistribution_kernel(m1, map = fish_raster, start = start,
                            stochastic = TRUE,
                            tolerance.outside = 0.1,
                            n.control = 1e3)

# Now simulate a path of length 30 for 50 times. This will lead a transient UD. For a steady state UD, either increase `n` or choose many more random starting points. 
n_steps = 1e3
n_steps1 = n_steps + 1
set.seed(2023)
p1 <- amt::simulate_path(x = k1, n = n_steps, start = start, verbose = TRUE)

# plot simulated track
ssf_track_1 <- fishmap +
  geom_polygon(data = nat_trans, aes(x=long,y=lat,group=group), fill = "grey80", color = "white") +
  geom_point(data = p1, aes(x = x_,y = y_), alpha = 0.61) +
  geom_path(data = p1, aes(x = x_,y = y_)) 


# estimate SSUD
uds_ssf1 <- tibble(rep = 1:n_steps1, 
    x_ = p1$x_, y_ = p1$y_,
    t_ = p1$t_, dt = p1$dt) |> 
  filter(!is.na(x_)) |> 
  make_track(x_, y_) |> 
  hr_kde(trast = fish_raster, which_min = "global") %>%
  hr_ud() %>% 
  terra::as.data.frame(xy = TRUE)

# plot SSUD
map_SSF1 <- ggplot() + 
  geom_tile(data = uds_ssf1, aes(x = x,y = y, fill = preydiv)) +
  scale_fill_viridis(option = "mako", name = "SSF2 prediction") +
  geom_polygon(data = nat_trans, aes(x=long,y=lat,group=group), fill = "grey80", color = "white") +
  coord_cartesian(xlim = c(150000,550000), ylim = c(-500000,-50000), expand = F) 
map_SSF1








### -------------- SSF2
# fit SSF2 model
m2 <- data_ssf |> 
  fit_clogit(case_ ~ preydiv_end +  preydiv_end:cos(ta_)+
               preydiv_end:log(sl_) + 
               # add terms for home range
               x2_ + y2_ + I(x2_^2 + y2_^2) +
               strata(step_id_))
summary(m2)


# Start with simulations
# First generate a redistribution kernel
set.seed(2023)
start <- make_start((seal %>%
                       mutate(date = as.POSIXct(date)) %>%
                       make_track(lon, lat, date))
                          # first location of the track as the start
                          [sample(1:nrow(seal), 1), ], 
                    dt_ = hours(2)) 

# generate redistribution kernel
k2 <- redistribution_kernel(m2, map = fish_raster, start = start,
                            stochastic = TRUE, 
                            tolerance.outside = 0.3,
                            n.control = 1e3)

# Now simulate a path of length 30 for 50 times. This will lead a transient UD. For a steady state UD, either increase `n` or choose many more random starting points. 
n_steps = 1e3
n_steps1 = n_steps + 1
set.seed(2023)
p2 <- amt::simulate_path(x = k2, n = n_steps, start = start)

# plot simulated track
ssf_track_2 <- fishmap +
  geom_polygon(data = nat_trans, aes(x=long,y=lat,group=group), fill = "grey80", color = "white") +
  geom_point(data = p2, aes(x = x_,y = y_), alpha = 0.61) +
  geom_path(data = p2, aes(x = x_,y = y_)) 


# estimate SSUD
uds_ssf2 <- tibble(rep = 1:n_steps1, 
    x_ = p1$x_, y_ = p1$y_,
    t_ = p1$t_, dt = p1$dt) |> 
  filter(!is.na(x_)) |> 
  make_track(x_, y_) |> 
  hr_kde(trast = fish_raster, which_min = "local") %>%
  hr_ud() %>% 
  terra::as.data.frame(xy = TRUE)

# plot SSUD
map_SSF2 <- ggplot() + 
  geom_tile(data = uds_ssf2, aes(x = x,y = y, fill = preydiv)) +
  scale_fill_viridis(option = "mako", name = "SSF2 prediction") +
  geom_polygon(data = nat_trans, aes(x=long,y=lat,group=group), fill = "grey80", color = "white") +
  coord_cartesian(xlim = c(150000,550000), ylim = c(-500000,-50000), expand = F) 
map_SSF2


plot_grid(map_SSF1, map_SSF2, ssf_track_1, ssf_track_2, nrow =2)


```
